"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/admin/analytics",{

/***/ "(pages-dir-browser)/./utils/adminApi.js":
/*!***************************!*\
  !*** ./utils/adminApi.js ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   approveLeave: () => (/* binding */ approveLeave),\n/* harmony export */   createCourse: () => (/* binding */ createCourse),\n/* harmony export */   createEvent: () => (/* binding */ createEvent),\n/* harmony export */   createInvoice: () => (/* binding */ createInvoice),\n/* harmony export */   createLeaveRequest: () => (/* binding */ createLeaveRequest),\n/* harmony export */   createSchedule: () => (/* binding */ createSchedule),\n/* harmony export */   createUser: () => (/* binding */ createUser),\n/* harmony export */   deleteCourse: () => (/* binding */ deleteCourse),\n/* harmony export */   deleteEvent: () => (/* binding */ deleteEvent),\n/* harmony export */   deleteInvoice: () => (/* binding */ deleteInvoice),\n/* harmony export */   deleteMessage: () => (/* binding */ deleteMessage),\n/* harmony export */   deleteSchedule: () => (/* binding */ deleteSchedule),\n/* harmony export */   deleteUser: () => (/* binding */ deleteUser),\n/* harmony export */   getAllAnalytics: () => (/* binding */ getAllAnalytics),\n/* harmony export */   getAttendance: () => (/* binding */ getAttendance),\n/* harmony export */   getAttendanceAnalytics: () => (/* binding */ getAttendanceAnalytics),\n/* harmony export */   getClasses: () => (/* binding */ getClasses),\n/* harmony export */   getCourses: () => (/* binding */ getCourses),\n/* harmony export */   getDepartmentDistribution: () => (/* binding */ getDepartmentDistribution),\n/* harmony export */   getDepartments: () => (/* binding */ getDepartments),\n/* harmony export */   getEvents: () => (/* binding */ getEvents),\n/* harmony export */   getFacultyPerformance: () => (/* binding */ getFacultyPerformance),\n/* harmony export */   getInvoices: () => (/* binding */ getInvoices),\n/* harmony export */   getLeaveRequests: () => (/* binding */ getLeaveRequests),\n/* harmony export */   getMessages: () => (/* binding */ getMessages),\n/* harmony export */   getRevenueData: () => (/* binding */ getRevenueData),\n/* harmony export */   getSchedules: () => (/* binding */ getSchedules),\n/* harmony export */   getSections: () => (/* binding */ getSections),\n/* harmony export */   getUsers: () => (/* binding */ getUsers),\n/* harmony export */   markInvoicePaid: () => (/* binding */ markInvoicePaid),\n/* harmony export */   rejectLeave: () => (/* binding */ rejectLeave),\n/* harmony export */   sendMessage: () => (/* binding */ sendMessage),\n/* harmony export */   updateAttendance: () => (/* binding */ updateAttendance),\n/* harmony export */   updateCourse: () => (/* binding */ updateCourse),\n/* harmony export */   updateEvent: () => (/* binding */ updateEvent),\n/* harmony export */   updateInvoice: () => (/* binding */ updateInvoice),\n/* harmony export */   updateLeaveStatus: () => (/* binding */ updateLeaveStatus),\n/* harmony export */   updateSchedule: () => (/* binding */ updateSchedule),\n/* harmony export */   updateUser: () => (/* binding */ updateUser)\n/* harmony export */ });\n/* harmony import */ var _mockData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mockData */ \"(pages-dir-browser)/./utils/mockData.js\");\n\n// Helper functions to simulate API calls using the mock data\n// =========== USER MANAGEMENT ===========\n/**\n * Get users (students or faculty) with optional filtering\n * @param {Object} queryParams - Filter parameters\n * @returns {Promise<Array>} - List of users\n */ const getUsers = async function() {\n    let queryParams = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const { role, departmentId, classId, sectionId, search } = queryParams;\n    // Determine which data set to use based on role\n    let userData = role === 'faculty' ? [\n        ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockFaculty\n    ] : [\n        ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockStudents\n    ];\n    // Apply filters\n    if (departmentId) {\n        userData = userData.filter((user)=>user.departmentId === parseInt(departmentId));\n    }\n    if (classId && role === 'student') {\n        userData = userData.filter((user)=>user.classId === parseInt(classId));\n    }\n    if (sectionId && role === 'student') {\n        userData = userData.filter((user)=>user.sectionId === parseInt(sectionId));\n    }\n    if (search) {\n        const searchLower = search.toLowerCase();\n        userData = userData.filter((user)=>user.name.toLowerCase().includes(searchLower) || user.email.toLowerCase().includes(searchLower));\n    }\n    return userData;\n};\n/**\n * Get departments\n * @returns {Promise<Array>} - List of departments\n */ const getDepartments = async ()=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    return [\n        ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockDepartments\n    ];\n};\n/**\n * Get classes with optional department filter\n * @param {number} departmentId - Department ID filter\n * @returns {Promise<Array>} - List of classes\n */ const getClasses = async (departmentId)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    let classData = [\n        ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockClasses\n    ];\n    if (departmentId) {\n        classData = classData.filter((cls)=>cls.departmentId === parseInt(departmentId));\n    }\n    return classData;\n};\n/**\n * Get sections with optional class filter\n * @param {number} classId - Class ID filter\n * @returns {Promise<Array>} - List of sections\n */ const getSections = async (classId)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    let sectionData = [\n        ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockSections\n    ];\n    if (classId) {\n        sectionData = sectionData.filter((section)=>section.classId === parseInt(classId));\n    }\n    return sectionData;\n};\n/**\n * Create a new user\n * @param {Object} userData - User data\n * @returns {Promise<Object>} - Created user\n */ const createUser = async (userData)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 800));\n    // Generate a new ID (in a real app, this would come from the backend)\n    const newId = userData.role === 'faculty' ? Math.max(..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockFaculty.map((f)=>f.id)) + 1 : Math.max(..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockStudents.map((s)=>s.id)) + 1;\n    const newUser = {\n        ...userData,\n        id: newId,\n        password_hash: 'hashed_' + userData.password,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n    };\n    // Add to the appropriate mock data array\n    if (userData.role === 'faculty') {\n        _mockData__WEBPACK_IMPORTED_MODULE_0__.mockFaculty.push(newUser);\n    } else {\n        _mockData__WEBPACK_IMPORTED_MODULE_0__.mockStudents.push(newUser);\n    }\n    return newUser;\n};\n/**\n * Update an existing user\n * @param {number} userId - User ID\n * @param {Object} userData - Updated user data\n * @returns {Promise<Object>} - Updated user\n */ const updateUser = async (userId, userData)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 800));\n    const id = parseInt(userId);\n    const isStudent = userData.role === 'student';\n    let userIndex;\n    let user;\n    if (isStudent) {\n        userIndex = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockStudents.findIndex((s)=>s.id === id);\n        if (userIndex === -1) throw new Error('Student not found');\n        user = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockStudents[userIndex];\n    } else {\n        userIndex = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockFaculty.findIndex((f)=>f.id === id);\n        if (userIndex === -1) throw new Error('Faculty not found');\n        user = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockFaculty[userIndex];\n    }\n    // Update user data\n    const updatedUser = {\n        ...user,\n        name: userData.name,\n        email: userData.email,\n        departmentId: userData.departmentId,\n        updated_at: new Date().toISOString()\n    };\n    // Update password if provided\n    if (userData.password) {\n        updatedUser.password_hash = 'hashed_' + userData.password;\n    }\n    // Update student-specific fields\n    if (isStudent) {\n        updatedUser.classId = userData.classId;\n        updatedUser.sectionId = userData.sectionId;\n        _mockData__WEBPACK_IMPORTED_MODULE_0__.mockStudents[userIndex] = updatedUser;\n    } else {\n        _mockData__WEBPACK_IMPORTED_MODULE_0__.mockFaculty[userIndex] = updatedUser;\n    }\n    return updatedUser;\n};\n/**\n * Delete a user\n * @param {number} userId - User ID\n * @returns {Promise<boolean>} - Success status\n */ const deleteUser = async (userId)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const id = parseInt(userId);\n    // Try to find and delete from students\n    const studentIndex = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockStudents.findIndex((s)=>s.id === id);\n    if (studentIndex !== -1) {\n        _mockData__WEBPACK_IMPORTED_MODULE_0__.mockStudents.splice(studentIndex, 1);\n        return true;\n    }\n    // Try to find and delete from faculty\n    const facultyIndex = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockFaculty.findIndex((f)=>f.id === id);\n    if (facultyIndex !== -1) {\n        _mockData__WEBPACK_IMPORTED_MODULE_0__.mockFaculty.splice(facultyIndex, 1);\n        return true;\n    }\n    throw new Error('User not found');\n};\n// =========== COURSES ===========\n/**\n * Get all courses with optional filters\n * @param {Object} queryParams - Filter parameters\n * @returns {Promise<Array>} - List of courses\n */ const getCourses = async function() {\n    let queryParams = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const { departmentId, search } = queryParams;\n    let courses = [\n        ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockCourses\n    ];\n    if (departmentId) {\n        courses = courses.filter((course)=>course.departmentId === parseInt(departmentId));\n    }\n    if (search) {\n        const searchLower = search.toLowerCase();\n        courses = courses.filter((course)=>course.name.toLowerCase().includes(searchLower) || course.course_code.toLowerCase().includes(searchLower));\n    }\n    return courses;\n};\n/**\n * Create a new course\n * @param {Object} courseData - Course data\n * @returns {Promise<Object>} - Created course\n */ const createCourse = async (courseData)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 800));\n    const newId = Math.max(..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockCourses.map((c)=>c.id)) + 1;\n    const newCourse = {\n        ...courseData,\n        id: newId,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n    };\n    _mockData__WEBPACK_IMPORTED_MODULE_0__.mockCourses.push(newCourse);\n    return newCourse;\n};\n/**\n * Update an existing course\n * @param {number} courseId - Course ID\n * @param {Object} courseData - Updated course data\n * @returns {Promise<Object>} - Updated course\n */ const updateCourse = async (courseId, courseData)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 800));\n    const id = parseInt(courseId);\n    const courseIndex = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockCourses.findIndex((c)=>c.id === id);\n    if (courseIndex === -1) throw new Error('Course not found');\n    const course = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockCourses[courseIndex];\n    const updatedCourse = {\n        ...course,\n        ...courseData,\n        id,\n        updated_at: new Date().toISOString()\n    };\n    _mockData__WEBPACK_IMPORTED_MODULE_0__.mockCourses[courseIndex] = updatedCourse;\n    return updatedCourse;\n};\n/**\n * Delete a course\n * @param {number} courseId - Course ID\n * @returns {Promise<boolean>} - Success status\n */ const deleteCourse = async (courseId)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const id = parseInt(courseId);\n    const courseIndex = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockCourses.findIndex((c)=>c.id === id);\n    if (courseIndex === -1) throw new Error('Course not found');\n    _mockData__WEBPACK_IMPORTED_MODULE_0__.mockCourses.splice(courseIndex, 1);\n    return true;\n};\n// =========== TIMETABLE / SCHEDULES ===========\n/**\n * Get schedules with optional filters\n * @param {Object} queryParams - Filter parameters\n * @returns {Promise<Array>} - List of schedules\n */ const getSchedules = async function() {\n    let queryParams = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const { view_type, departmentId, classId, sectionId, facultyId, day } = queryParams;\n    let schedules = [\n        ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockSchedules\n    ];\n    if (day) {\n        schedules = schedules.filter((schedule)=>schedule.day_of_week === day);\n    }\n    if (view_type === 'student') {\n        // Student view filters\n        if (departmentId && !classId) {\n            schedules = schedules.filter((schedule)=>{\n                var _mockClasses_find;\n                return ((_mockClasses_find = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockClasses.find((c)=>c.id === schedule.classId)) === null || _mockClasses_find === void 0 ? void 0 : _mockClasses_find.departmentId) === parseInt(departmentId);\n            });\n        }\n        if (classId) {\n            schedules = schedules.filter((schedule)=>schedule.classId === parseInt(classId));\n        }\n        if (sectionId) {\n            schedules = schedules.filter((schedule)=>schedule.sectionId === parseInt(sectionId));\n        }\n    } else {\n        // Faculty view filters\n        if (facultyId) {\n            schedules = schedules.filter((schedule)=>schedule.facultyId === parseInt(facultyId));\n        }\n        if (departmentId) {\n            schedules = schedules.filter((schedule)=>{\n                var _mockFaculty_find;\n                return ((_mockFaculty_find = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockFaculty.find((f)=>f.id === schedule.facultyId)) === null || _mockFaculty_find === void 0 ? void 0 : _mockFaculty_find.departmentId) === parseInt(departmentId);\n            });\n        }\n    }\n    // Add related data (in a real implementation, this would be done with joins in the database query)\n    const schedulesWithRelated = schedules.map((schedule)=>{\n        const course = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockCourses.find((c)=>c.id === schedule.courseId);\n        const faculty = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockFaculty.find((f)=>f.id === schedule.facultyId);\n        const classInfo = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockClasses.find((c)=>c.id === schedule.classId);\n        const section = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockSections.find((s)=>s.id === schedule.sectionId);\n        return {\n            ...schedule,\n            course,\n            faculty,\n            class: classInfo,\n            section\n        };\n    });\n    return schedulesWithRelated;\n};\n/**\n * Create a new schedule\n * @param {Object} scheduleData - Schedule data\n * @returns {Promise<Object>} - Created schedule\n */ const createSchedule = async (scheduleData)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 800));\n    const newId = Math.max(..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockSchedules.map((s)=>s.id)) + 1;\n    const newSchedule = {\n        ...scheduleData,\n        id: newId\n    };\n    _mockData__WEBPACK_IMPORTED_MODULE_0__.mockSchedules.push(newSchedule);\n    // Return with related data\n    const course = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockCourses.find((c)=>c.id === newSchedule.courseId);\n    const faculty = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockFaculty.find((f)=>f.id === newSchedule.facultyId);\n    const classInfo = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockClasses.find((c)=>c.id === newSchedule.classId);\n    const section = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockSections.find((s)=>s.id === newSchedule.sectionId);\n    return {\n        ...newSchedule,\n        course,\n        faculty,\n        class: classInfo,\n        section\n    };\n};\n/**\n * Update a schedule\n * @param {number} scheduleId - Schedule ID\n * @param {Object} scheduleData - Updated schedule data\n * @returns {Promise<Object>} - Updated schedule\n */ const updateSchedule = async (scheduleId, scheduleData)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 800));\n    const id = parseInt(scheduleId);\n    const scheduleIndex = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockSchedules.findIndex((s)=>s.id === id);\n    if (scheduleIndex === -1) throw new Error('Schedule not found');\n    const schedule = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockSchedules[scheduleIndex];\n    const updatedSchedule = {\n        ...schedule,\n        ...scheduleData,\n        id\n    };\n    _mockData__WEBPACK_IMPORTED_MODULE_0__.mockSchedules[scheduleIndex] = updatedSchedule;\n    // Return with related data\n    const course = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockCourses.find((c)=>c.id === updatedSchedule.courseId);\n    const faculty = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockFaculty.find((f)=>f.id === updatedSchedule.facultyId);\n    const classInfo = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockClasses.find((c)=>c.id === updatedSchedule.classId);\n    const section = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockSections.find((s)=>s.id === updatedSchedule.sectionId);\n    return {\n        ...updatedSchedule,\n        course,\n        faculty,\n        class: classInfo,\n        section\n    };\n};\n/**\n * Delete a schedule\n * @param {number} scheduleId - Schedule ID\n * @returns {Promise<boolean>} - Success status\n */ const deleteSchedule = async (scheduleId)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const id = parseInt(scheduleId);\n    const scheduleIndex = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockSchedules.findIndex((s)=>s.id === id);\n    if (scheduleIndex === -1) throw new Error('Schedule not found');\n    _mockData__WEBPACK_IMPORTED_MODULE_0__.mockSchedules.splice(scheduleIndex, 1);\n    return true;\n};\n// =========== ATTENDANCE ===========\n/**\n * Get attendance with optional filters\n * @param {Object} queryParams - Filter parameters\n * @returns {Promise<Array>} - List of attendance records\n */ const getAttendance = async function() {\n    let queryParams = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const { view_type, departmentId, classId, sectionId, courseId, facultyId, date, status } = queryParams;\n    let attendance = [\n        ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockAttendance\n    ];\n    if (date) {\n        const dateObj = new Date(date);\n        const year = dateObj.getFullYear();\n        const month = dateObj.getMonth();\n        const day = dateObj.getDate();\n        attendance = attendance.filter((a)=>{\n            const recordDate = new Date(a.date);\n            return recordDate.getFullYear() === year && recordDate.getMonth() === month && recordDate.getDate() === day;\n        });\n    }\n    if (status) {\n        attendance = attendance.filter((a)=>a.status === status);\n    }\n    if (view_type === 'student') {\n        // Student attendance filters\n        if (courseId) {\n            attendance = attendance.filter((a)=>a.courseId === parseInt(courseId));\n        }\n        if (departmentId || classId || sectionId) {\n            attendance = attendance.filter((a)=>{\n                const student = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockStudents.find((s)=>s.id === a.studentId);\n                if (!student) return false;\n                if (departmentId && student.departmentId !== parseInt(departmentId)) return false;\n                if (classId && student.classId !== parseInt(classId)) return false;\n                if (sectionId && student.sectionId !== parseInt(sectionId)) return false;\n                return true;\n            });\n        }\n    } else {\n        // Faculty view would be implemented differently\n        // For now, we'll return empty for faculty view to match the current implementation\n        return [];\n    }\n    // Add related data\n    const attendanceWithRelated = attendance.map((record)=>{\n        const student = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockStudents.find((s)=>s.id === record.studentId);\n        const course = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockCourses.find((c)=>c.id === record.courseId);\n        return {\n            ...record,\n            student,\n            course\n        };\n    });\n    return attendanceWithRelated;\n};\n/**\n * Update attendance status\n * @param {number} attendanceId - Attendance ID\n * @param {Object} data - Update data (status)\n * @returns {Promise<Object>} - Updated attendance record\n */ const updateAttendance = async (attendanceId, data)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const id = parseInt(attendanceId);\n    const attendanceIndex = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockAttendance.findIndex((a)=>a.id === id);\n    if (attendanceIndex === -1) throw new Error('Attendance record not found');\n    const attendance = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockAttendance[attendanceIndex];\n    const updatedAttendance = {\n        ...attendance,\n        status: data.status\n    };\n    _mockData__WEBPACK_IMPORTED_MODULE_0__.mockAttendance[attendanceIndex] = updatedAttendance;\n    // Return with related data\n    const student = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockStudents.find((s)=>s.id === updatedAttendance.studentId);\n    const course = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockCourses.find((c)=>c.id === updatedAttendance.courseId);\n    return {\n        ...updatedAttendance,\n        student,\n        course\n    };\n};\n/**\n * Get attendance analytics\n * @returns {Promise<Object>} - Attendance analytics data\n */ const getAttendanceAnalytics = async ()=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    return _mockData__WEBPACK_IMPORTED_MODULE_0__.mockAttendanceAnalytics;\n};\n// =========== EVENTS ===========\n/**\n * Get events with optional filters\n * @param {Object} queryParams - Filter parameters\n * @returns {Promise<Array>} - List of events\n */ const getEvents = async function() {\n    let queryParams = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const { from_date, to_date, audience_type } = queryParams;\n    let events = [\n        ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockEvents\n    ];\n    if (from_date) {\n        const fromDate = new Date(from_date);\n        events = events.filter((event)=>new Date(event.event_date) >= fromDate);\n    }\n    if (to_date) {\n        const toDate = new Date(to_date);\n        events = events.filter((event)=>new Date(event.event_date) <= toDate);\n    }\n    // Todo: Add audience_type filtering if needed\n    return events;\n};\n/**\n * Create a new event\n * @param {Object} eventData - Event data\n * @returns {Promise<Object>} - Created event\n */ const createEvent = async (eventData)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 800));\n    const newId = Math.max(..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockEvents.map((e)=>e.id)) + 1;\n    const newEvent = {\n        ...eventData,\n        id: newId,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n    };\n    _mockData__WEBPACK_IMPORTED_MODULE_0__.mockEvents.push(newEvent);\n    return newEvent;\n};\n/**\n * Update an event\n * @param {number} eventId - Event ID\n * @param {Object} eventData - Updated event data\n * @returns {Promise<Object>} - Updated event\n */ const updateEvent = async (eventId, eventData)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 800));\n    const id = parseInt(eventId);\n    const eventIndex = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockEvents.findIndex((e)=>e.id === id);\n    if (eventIndex === -1) throw new Error('Event not found');\n    const event = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockEvents[eventIndex];\n    const updatedEvent = {\n        ...event,\n        ...eventData,\n        id,\n        updated_at: new Date().toISOString()\n    };\n    _mockData__WEBPACK_IMPORTED_MODULE_0__.mockEvents[eventIndex] = updatedEvent;\n    return updatedEvent;\n};\n/**\n * Delete an event\n * @param {number} eventId - Event ID\n * @returns {Promise<boolean>} - Success status\n */ const deleteEvent = async (eventId)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const id = parseInt(eventId);\n    const eventIndex = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockEvents.findIndex((e)=>e.id === id);\n    if (eventIndex === -1) throw new Error('Event not found');\n    _mockData__WEBPACK_IMPORTED_MODULE_0__.mockEvents.splice(eventIndex, 1);\n    return true;\n};\n// =========== INVOICES ===========\n/**\n * Get invoices with optional filters\n * @param {Object} queryParams - Filter parameters\n * @returns {Promise<Array>} - List of invoices\n */ const getInvoices = async function() {\n    let queryParams = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const { studentId, paid, from_date, to_date } = queryParams;\n    let invoices = [\n        ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockInvoices\n    ];\n    if (studentId) {\n        invoices = invoices.filter((invoice)=>invoice.studentId === parseInt(studentId));\n    }\n    if (paid !== undefined) {\n        const isPaid = paid === 'true' || paid === true;\n        invoices = invoices.filter((invoice)=>invoice.paid === isPaid);\n    }\n    if (from_date) {\n        const fromDate = new Date(from_date);\n        invoices = invoices.filter((invoice)=>new Date(invoice.generated_at) >= fromDate);\n    }\n    if (to_date) {\n        const toDate = new Date(to_date);\n        invoices = invoices.filter((invoice)=>new Date(invoice.generated_at) <= toDate);\n    }\n    // Add student data to each invoice\n    const invoicesWithStudents = invoices.map((invoice)=>{\n        const student = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockStudents.find((s)=>s.id === invoice.studentId);\n        return {\n            ...invoice,\n            student\n        };\n    });\n    return invoicesWithStudents;\n};\n/**\n * Create a new invoice\n * @param {Object} invoiceData - Invoice data\n * @returns {Promise<Object>} - Created invoice\n */ const createInvoice = async (invoiceData)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 800));\n    const newId = Math.max(..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockInvoices.map((i)=>i.id)) + 1;\n    // Generate invoice number\n    const today = new Date();\n    const invoiceNumber = \"INV-\".concat(today.getFullYear(), \"-\").concat(String(newId).padStart(3, '0'));\n    const newInvoice = {\n        ...invoiceData,\n        id: newId,\n        invoice_number: invoiceNumber,\n        paid: false,\n        generated_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n    };\n    _mockData__WEBPACK_IMPORTED_MODULE_0__.mockInvoices.push(newInvoice);\n    // Add student data\n    const student = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockStudents.find((s)=>s.id === newInvoice.studentId);\n    return {\n        ...newInvoice,\n        student\n    };\n};\n/**\n * Update an invoice\n * @param {number} invoiceId - Invoice ID\n * @param {Object} invoiceData - Updated invoice data\n * @returns {Promise<Object>} - Updated invoice\n */ const updateInvoice = async (invoiceId, invoiceData)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 800));\n    const id = parseInt(invoiceId);\n    const invoiceIndex = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockInvoices.findIndex((i)=>i.id === id);\n    if (invoiceIndex === -1) throw new Error('Invoice not found');\n    const invoice = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockInvoices[invoiceIndex];\n    const updatedInvoice = {\n        ...invoice,\n        ...invoiceData,\n        id,\n        updated_at: new Date().toISOString()\n    };\n    _mockData__WEBPACK_IMPORTED_MODULE_0__.mockInvoices[invoiceIndex] = updatedInvoice;\n    // Add student data\n    const student = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockStudents.find((s)=>s.id === updatedInvoice.studentId);\n    return {\n        ...updatedInvoice,\n        student\n    };\n};\n/**\n * Delete an invoice\n * @param {number} invoiceId - Invoice ID\n * @returns {Promise<boolean>} - Success status\n */ const deleteInvoice = async (invoiceId)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const id = parseInt(invoiceId);\n    const invoiceIndex = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockInvoices.findIndex((i)=>i.id === id);\n    if (invoiceIndex === -1) throw new Error('Invoice not found');\n    _mockData__WEBPACK_IMPORTED_MODULE_0__.mockInvoices.splice(invoiceIndex, 1);\n    return true;\n};\n/**\n * Mark an invoice as paid\n * @param {number} invoiceId - Invoice ID\n * @returns {Promise<Object>} - Updated invoice\n */ const markInvoicePaid = async (invoiceId)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const id = parseInt(invoiceId);\n    const invoiceIndex = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockInvoices.findIndex((i)=>i.id === id);\n    if (invoiceIndex === -1) throw new Error('Invoice not found');\n    const invoice = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockInvoices[invoiceIndex];\n    const updatedInvoice = {\n        ...invoice,\n        paid: true,\n        updated_at: new Date().toISOString()\n    };\n    _mockData__WEBPACK_IMPORTED_MODULE_0__.mockInvoices[invoiceIndex] = updatedInvoice;\n    // Add student data\n    const student = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockStudents.find((s)=>s.id === updatedInvoice.studentId);\n    return {\n        ...updatedInvoice,\n        student\n    };\n};\n// =========== MESSAGES ===========\n/**\n * Get messages with optional filters\n * @param {Object} queryParams - Filter parameters\n * @returns {Promise<Array>} - List of messages\n */ const getMessages = async function() {\n    let queryParams = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const { filter } = queryParams;\n    // Admin ID (in a real app, would come from auth)\n    const adminId = 1;\n    let messages = [\n        ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockMessages\n    ];\n    if (filter === 'inbox') {\n        // Messages received by admin\n        messages = messages.filter((msg)=>msg.receiver_id === adminId && msg.receiver_type === 'admin');\n    } else if (filter === 'sent') {\n        // Messages sent by admin\n        messages = messages.filter((msg)=>msg.sender_id === adminId && msg.sender_type === 'admin');\n    } else {\n        // All messages (both sent and received)\n        messages = messages.filter((msg)=>msg.sender_id === adminId && msg.sender_type === 'admin' || msg.receiver_id === adminId && msg.receiver_type === 'admin');\n    }\n    // Enhance messages with sender and receiver names\n    // In a real implementation, this would be handled with joins in the database query\n    const enhancedMessages = messages.map((message)=>{\n        let senderName = 'Unknown';\n        let receiverName = 'Unknown';\n        // Get sender name\n        if (message.sender_type === 'student') {\n            const student = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockStudents.find((s)=>s.id === message.sender_id);\n            senderName = student ? student.name : 'Unknown Student';\n        } else if (message.sender_type === 'faculty') {\n            const faculty = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockFaculty.find((f)=>f.id === message.sender_id);\n            senderName = faculty ? faculty.name : 'Unknown Faculty';\n        } else if (message.sender_type === 'admin') {\n            senderName = 'Admin User';\n        }\n        // Get receiver name\n        if (message.receiver_type === 'student') {\n            const student = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockStudents.find((s)=>s.id === message.receiver_id);\n            receiverName = student ? student.name : 'Unknown Student';\n        } else if (message.receiver_type === 'faculty') {\n            const faculty = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockFaculty.find((f)=>f.id === message.receiver_id);\n            receiverName = faculty ? faculty.name : 'Unknown Faculty';\n        } else if (message.receiver_type === 'admin') {\n            receiverName = 'Admin User';\n        }\n        return {\n            ...message,\n            sender_name: senderName,\n            receiver_name: receiverName\n        };\n    });\n    return enhancedMessages;\n};\n/**\n * Send a new message\n * @param {Object} messageData - Message data\n * @returns {Promise<Object>} - Created message\n */ const sendMessage = async (messageData)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 800));\n    const newId = Math.max(..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockMessages.map((m)=>m.id)) + 1;\n    // Admin ID (in a real app, would come from auth)\n    const adminId = 1;\n    const newMessage = {\n        ...messageData,\n        id: newId,\n        sender_id: adminId,\n        sender_type: 'admin',\n        sent_at: new Date().toISOString()\n    };\n    _mockData__WEBPACK_IMPORTED_MODULE_0__.mockMessages.push(newMessage);\n    // Get sender and receiver names\n    let senderName = 'Admin User';\n    let receiverName = 'Unknown';\n    if (newMessage.receiver_type === 'student') {\n        const student = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockStudents.find((s)=>s.id === newMessage.receiver_id);\n        receiverName = student ? student.name : 'Unknown Student';\n    } else if (newMessage.receiver_type === 'faculty') {\n        const faculty = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockFaculty.find((f)=>f.id === newMessage.receiver_id);\n        receiverName = faculty ? faculty.name : 'Unknown Faculty';\n    } else if (newMessage.receiver_type === 'admin') {\n        const admin = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockStudents.find((a)=>a.id === newMessage.receiver_id);\n        receiverName = admin ? admin.name : 'Admin User';\n    }\n    return {\n        ...newMessage,\n        sender_name: senderName,\n        receiver_name: receiverName\n    };\n};\n/**\n * Delete a message\n * @param {number} messageId - Message ID\n * @returns {Promise<boolean>} - Success status\n */ const deleteMessage = async (messageId)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const id = parseInt(messageId);\n    const messageIndex = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockMessages.findIndex((m)=>m.id === id);\n    if (messageIndex === -1) throw new Error('Message not found');\n    _mockData__WEBPACK_IMPORTED_MODULE_0__.mockMessages.splice(messageIndex, 1);\n    return true;\n};\n// =========== LEAVE REQUESTS ===========\n/**\n * Get leave requests with optional filters\n * @param {Object} queryParams - Filter parameters\n * @returns {Promise<Array>} - List of leave requests\n */ const getLeaveRequests = async function() {\n    let queryParams = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const { status, departmentId, facultyId, date_from, date_to } = queryParams;\n    let leaveRequests = [\n        ..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockLeaveRequests\n    ];\n    if (status) {\n        leaveRequests = leaveRequests.filter((request)=>request.status === status);\n    }\n    if (departmentId) {\n        leaveRequests = leaveRequests.filter((request)=>request.departmentId === parseInt(departmentId));\n    }\n    if (facultyId) {\n        leaveRequests = leaveRequests.filter((request)=>request.facultyId === parseInt(facultyId));\n    }\n    if (date_from) {\n        const fromDate = new Date(date_from);\n        leaveRequests = leaveRequests.filter((request)=>new Date(request.leave_date) >= fromDate);\n    }\n    if (date_to) {\n        const toDate = new Date(date_to);\n        leaveRequests = leaveRequests.filter((request)=>new Date(request.leave_date) <= toDate);\n    }\n    // Add related data\n    const requestsWithRelated = leaveRequests.map((request)=>{\n        const faculty = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockFaculty.find((f)=>f.id === request.facultyId);\n        const department = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockDepartments.find((d)=>d.id === request.departmentId);\n        const classInfo = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockClasses.find((c)=>c.id === request.classId);\n        const section = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockSections.find((s)=>s.id === request.sectionId);\n        const course = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockCourses.find((c)=>c.id === request.courseId);\n        return {\n            ...request,\n            faculty,\n            department,\n            class: classInfo,\n            section,\n            course\n        };\n    });\n    return requestsWithRelated;\n};\n/**\n * Create a new leave request\n * @param {Object} leaveData - Leave request data\n * @returns {Promise<Object>} - Created leave request\n */ const createLeaveRequest = async (leaveData)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 800));\n    const newId = Math.max(..._mockData__WEBPACK_IMPORTED_MODULE_0__.mockLeaveRequests.map((r)=>r.id)) + 1;\n    const newRequest = {\n        ...leaveData,\n        id: newId,\n        status: 'Pending',\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n    };\n    _mockData__WEBPACK_IMPORTED_MODULE_0__.mockLeaveRequests.push(newRequest);\n    // Add related data\n    const faculty = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockFaculty.find((f)=>f.id === newRequest.facultyId);\n    const department = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockDepartments.find((d)=>d.id === newRequest.departmentId);\n    const classInfo = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockClasses.find((c)=>c.id === newRequest.classId);\n    const section = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockSections.find((s)=>s.id === newRequest.sectionId);\n    const course = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockCourses.find((c)=>c.id === newRequest.courseId);\n    return {\n        ...newRequest,\n        faculty,\n        department,\n        class: classInfo,\n        section,\n        course\n    };\n};\n/**\n * Update leave request status\n * @param {number} leaveId - Leave request ID\n * @param {Object} data - Update data (status)\n * @returns {Promise<Object>} - Updated leave request\n */ const updateLeaveStatus = async (leaveId, data)=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const id = parseInt(leaveId);\n    const leaveIndex = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockLeaveRequests.findIndex((r)=>r.id === id);\n    if (leaveIndex === -1) throw new Error('Leave request not found');\n    const leave = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockLeaveRequests[leaveIndex];\n    const updatedLeave = {\n        ...leave,\n        status: data.status,\n        updated_at: new Date().toISOString()\n    };\n    _mockData__WEBPACK_IMPORTED_MODULE_0__.mockLeaveRequests[leaveIndex] = updatedLeave;\n    // Add related data\n    const faculty = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockFaculty.find((f)=>f.id === updatedLeave.facultyId);\n    const department = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockDepartments.find((d)=>d.id === updatedLeave.departmentId);\n    const classInfo = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockClasses.find((c)=>c.id === updatedLeave.classId);\n    const section = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockSections.find((s)=>s.id === updatedLeave.sectionId);\n    const course = _mockData__WEBPACK_IMPORTED_MODULE_0__.mockCourses.find((c)=>c.id === updatedLeave.courseId);\n    return {\n        ...updatedLeave,\n        faculty,\n        department,\n        class: classInfo,\n        section,\n        course\n    };\n};\n/**\n * Approve a leave request\n * @param {number} leaveId - Leave request ID\n * @returns {Promise<Object>} - Updated leave request\n */ const approveLeave = async (leaveId)=>{\n    return updateLeaveStatus(leaveId, {\n        status: 'Approved'\n    });\n};\n/**\n * Reject a leave request\n * @param {number} leaveId - Leave request ID\n * @returns {Promise<Object>} - Updated leave request\n */ const rejectLeave = async (leaveId)=>{\n    return updateLeaveStatus(leaveId, {\n        status: 'Rejected'\n    });\n};\n// =========== ANALYTICS ===========\n/**\n * Get all analytics data\n * @returns {Promise<Object>} - Analytics data\n */ const getAllAnalytics = async ()=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 800));\n    return {\n        departmentDistribution: _mockData__WEBPACK_IMPORTED_MODULE_0__.mockDepartmentDistribution,\n        facultyPerformance: _mockData__WEBPACK_IMPORTED_MODULE_0__.mockFacultyPerformance,\n        revenueData: _mockData__WEBPACK_IMPORTED_MODULE_0__.mockRevenueData,\n        attendanceAnalytics: _mockData__WEBPACK_IMPORTED_MODULE_0__.mockAttendanceAnalytics\n    };\n};\n/**\n * Get department distribution analytics\n * @returns {Promise<Object>} - Department distribution data\n */ const getDepartmentDistribution = async ()=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    return _mockData__WEBPACK_IMPORTED_MODULE_0__.mockDepartmentDistribution;\n};\n/**\n * Get faculty performance analytics\n * @returns {Promise<Object>} - Faculty performance data\n */ const getFacultyPerformance = async ()=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    return _mockData__WEBPACK_IMPORTED_MODULE_0__.mockFacultyPerformance;\n};\n/**\n * Get revenue analytics\n * @returns {Promise<Object>} - Revenue data\n */ const getRevenueData = async ()=>{\n    // Simulate network request\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    return _mockData__WEBPACK_IMPORTED_MODULE_0__.mockRevenueData;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3V0aWxzL2FkbWluQXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQm9CO0FBRXBCLDZEQUE2RDtBQUU3RCwwQ0FBMEM7QUFFMUM7Ozs7Q0FJQyxHQUNNLE1BQU1nQixXQUFXO1FBQU9DLCtFQUFjLENBQUM7SUFDNUMsMkJBQTJCO0lBQzNCLE1BQU0sSUFBSUMsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztJQUVqRCxNQUFNLEVBQUVFLElBQUksRUFBRUMsWUFBWSxFQUFFQyxPQUFPLEVBQUVDLFNBQVMsRUFBRUMsTUFBTSxFQUFFLEdBQUdSO0lBRTNELGdEQUFnRDtJQUNoRCxJQUFJUyxXQUFXTCxTQUFTLFlBQVk7V0FBSXBCLGtEQUFXQTtLQUFDLEdBQUc7V0FBSUQsbURBQVlBO0tBQUM7SUFFeEUsZ0JBQWdCO0lBQ2hCLElBQUlzQixjQUFjO1FBQ2hCSSxXQUFXQSxTQUFTQyxNQUFNLENBQUNDLENBQUFBLE9BQVFBLEtBQUtOLFlBQVksS0FBS08sU0FBU1A7SUFDcEU7SUFFQSxJQUFJQyxXQUFXRixTQUFTLFdBQVc7UUFDakNLLFdBQVdBLFNBQVNDLE1BQU0sQ0FBQ0MsQ0FBQUEsT0FBUUEsS0FBS0wsT0FBTyxLQUFLTSxTQUFTTjtJQUMvRDtJQUVBLElBQUlDLGFBQWFILFNBQVMsV0FBVztRQUNuQ0ssV0FBV0EsU0FBU0MsTUFBTSxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLSixTQUFTLEtBQUtLLFNBQVNMO0lBQ2pFO0lBRUEsSUFBSUMsUUFBUTtRQUNWLE1BQU1LLGNBQWNMLE9BQU9NLFdBQVc7UUFDdENMLFdBQVdBLFNBQVNDLE1BQU0sQ0FBQ0MsQ0FBQUEsT0FDekJBLEtBQUtJLElBQUksQ0FBQ0QsV0FBVyxHQUFHRSxRQUFRLENBQUNILGdCQUNqQ0YsS0FBS00sS0FBSyxDQUFDSCxXQUFXLEdBQUdFLFFBQVEsQ0FBQ0g7SUFFdEM7SUFFQSxP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LFFBQVE7SUFBVztBQUN6RCxFQUFFO0FBRUY7Ozs7Q0FJQyxHQUNNLE1BQU11RyxjQUFjLE9BQU9MO0lBQ2hDLE9BQU9ELGtCQUFrQkMsU0FBUztRQUFFbEcsUUFBUTtJQUFXO0FBQ3pELEVBQUU7QUFFRixvQ0FBb0M7QUFFcEM7OztDQUdDLEdBQ00sTUFBTXdHLGtCQUFrQjtJQUM3QiwyQkFBMkI7SUFDM0IsTUFBTSxJQUFJOUwsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztJQUVqRCxPQUFPO1FBQ0w4TCx3QkFBd0JwTSxpRUFBMEJBO1FBQ2xEcU0sb0JBQW9CcE0sNkRBQXNCQTtRQUMxQ3FNLGFBQWFwTSxzREFBZUE7UUFDNUJxTSxxQkFBcUJ4TSw4REFBdUJBO0lBQzlDO0FBQ0YsRUFBRTtBQUVGOzs7Q0FHQyxHQUNNLE1BQU15TSw0QkFBNEI7SUFDdkMsMkJBQTJCO0lBQzNCLE1BQU0sSUFBSW5NLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7SUFFakQsT0FBT04saUVBQTBCQTtBQUNuQyxFQUFFO0FBRUY7OztDQUdDLEdBQ00sTUFBTXlNLHdCQUF3QjtJQUNuQywyQkFBMkI7SUFDM0IsTUFBTSxJQUFJcE0sUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztJQUVqRCxPQUFPTCw2REFBc0JBO0FBQy9CLEVBQUU7QUFFRjs7O0NBR0MsR0FDTSxNQUFNeU0saUJBQWlCO0lBQzVCLDJCQUEyQjtJQUMzQixNQUFNLElBQUlyTSxRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTO0lBRWpELE9BQU9KLHNEQUFlQTtBQUN4QixFQUFFIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL3V0aWxzL2FkbWluQXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFxuICBtb2NrU3R1ZGVudHMsIFxuICBtb2NrRmFjdWx0eSwgXG4gIG1vY2tEZXBhcnRtZW50cywgXG4gIG1vY2tDbGFzc2VzLCBcbiAgbW9ja1NlY3Rpb25zLFxuICBtb2NrQ291cnNlcyxcbiAgbW9ja1NjaGVkdWxlcyxcbiAgbW9ja0F0dGVuZGFuY2UsXG4gIG1vY2tFdmVudHMsXG4gIG1vY2tJbnZvaWNlcyxcbiAgbW9ja01lc3NhZ2VzLFxuICBtb2NrTGVhdmVSZXF1ZXN0cyxcbiAgbW9ja0F0dGVuZGFuY2VBbmFseXRpY3MsXG4gIG1vY2tEZXBhcnRtZW50RGlzdHJpYnV0aW9uLFxuICBtb2NrRmFjdWx0eVBlcmZvcm1hbmNlLFxuICBtb2NrUmV2ZW51ZURhdGFcbn0gZnJvbSAnLi9tb2NrRGF0YSc7XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgdG8gc2ltdWxhdGUgQVBJIGNhbGxzIHVzaW5nIHRoZSBtb2NrIGRhdGFcblxuLy8gPT09PT09PT09PT0gVVNFUiBNQU5BR0VNRU5UID09PT09PT09PT09XG5cbi8qKlxuICogR2V0IHVzZXJzIChzdHVkZW50cyBvciBmYWN1bHR5KSB3aXRoIG9wdGlvbmFsIGZpbHRlcmluZ1xuICogQHBhcmFtIHtPYmplY3R9IHF1ZXJ5UGFyYW1zIC0gRmlsdGVyIHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5Pn0gLSBMaXN0IG9mIHVzZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRVc2VycyA9IGFzeW5jIChxdWVyeVBhcmFtcyA9IHt9KSA9PiB7XG4gIC8vIFNpbXVsYXRlIG5ldHdvcmsgcmVxdWVzdFxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gIFxuICBjb25zdCB7IHJvbGUsIGRlcGFydG1lbnRJZCwgY2xhc3NJZCwgc2VjdGlvbklkLCBzZWFyY2ggfSA9IHF1ZXJ5UGFyYW1zO1xuICBcbiAgLy8gRGV0ZXJtaW5lIHdoaWNoIGRhdGEgc2V0IHRvIHVzZSBiYXNlZCBvbiByb2xlXG4gIGxldCB1c2VyRGF0YSA9IHJvbGUgPT09ICdmYWN1bHR5JyA/IFsuLi5tb2NrRmFjdWx0eV0gOiBbLi4ubW9ja1N0dWRlbnRzXTtcbiAgXG4gIC8vIEFwcGx5IGZpbHRlcnNcbiAgaWYgKGRlcGFydG1lbnRJZCkge1xuICAgIHVzZXJEYXRhID0gdXNlckRhdGEuZmlsdGVyKHVzZXIgPT4gdXNlci5kZXBhcnRtZW50SWQgPT09IHBhcnNlSW50KGRlcGFydG1lbnRJZCkpO1xuICB9XG4gIFxuICBpZiAoY2xhc3NJZCAmJiByb2xlID09PSAnc3R1ZGVudCcpIHtcbiAgICB1c2VyRGF0YSA9IHVzZXJEYXRhLmZpbHRlcih1c2VyID0+IHVzZXIuY2xhc3NJZCA9PT0gcGFyc2VJbnQoY2xhc3NJZCkpO1xuICB9XG4gIFxuICBpZiAoc2VjdGlvbklkICYmIHJvbGUgPT09ICdzdHVkZW50Jykge1xuICAgIHVzZXJEYXRhID0gdXNlckRhdGEuZmlsdGVyKHVzZXIgPT4gdXNlci5zZWN0aW9uSWQgPT09IHBhcnNlSW50KHNlY3Rpb25JZCkpO1xuICB9XG4gIFxuICBpZiAoc2VhcmNoKSB7XG4gICAgY29uc3Qgc2VhcmNoTG93ZXIgPSBzZWFyY2gudG9Mb3dlckNhc2UoKTtcbiAgICB1c2VyRGF0YSA9IHVzZXJEYXRhLmZpbHRlcih1c2VyID0+IFxuICAgICAgdXNlci5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoTG93ZXIpIHx8IFxuICAgICAgdXNlci5lbWFpbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaExvd2VyKVxuICAgICk7XG4gIH1cbiAgXG4gIHJldHVybiB1c2VyRGF0YTtcbn07XG5cbi8qKlxuICogR2V0IGRlcGFydG1lbnRzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59IC0gTGlzdCBvZiBkZXBhcnRtZW50c1xuICovXG5leHBvcnQgY29uc3QgZ2V0RGVwYXJ0bWVudHMgPSBhc3luYyAoKSA9PiB7XG4gIC8vIFNpbXVsYXRlIG5ldHdvcmsgcmVxdWVzdFxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSk7XG4gIFxuICByZXR1cm4gWy4uLm1vY2tEZXBhcnRtZW50c107XG59O1xuXG4vKipcbiAqIEdldCBjbGFzc2VzIHdpdGggb3B0aW9uYWwgZGVwYXJ0bWVudCBmaWx0ZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXBhcnRtZW50SWQgLSBEZXBhcnRtZW50IElEIGZpbHRlclxuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fSAtIExpc3Qgb2YgY2xhc3Nlc1xuICovXG5leHBvcnQgY29uc3QgZ2V0Q2xhc3NlcyA9IGFzeW5jIChkZXBhcnRtZW50SWQpID0+IHtcbiAgLy8gU2ltdWxhdGUgbmV0d29yayByZXF1ZXN0XG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKTtcbiAgXG4gIGxldCBjbGFzc0RhdGEgPSBbLi4ubW9ja0NsYXNzZXNdO1xuICBcbiAgaWYgKGRlcGFydG1lbnRJZCkge1xuICAgIGNsYXNzRGF0YSA9IGNsYXNzRGF0YS5maWx0ZXIoY2xzID0+IGNscy5kZXBhcnRtZW50SWQgPT09IHBhcnNlSW50KGRlcGFydG1lbnRJZCkpO1xuICB9XG4gIFxuICByZXR1cm4gY2xhc3NEYXRhO1xufTtcblxuLyoqXG4gKiBHZXQgc2VjdGlvbnMgd2l0aCBvcHRpb25hbCBjbGFzcyBmaWx0ZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbGFzc0lkIC0gQ2xhc3MgSUQgZmlsdGVyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59IC0gTGlzdCBvZiBzZWN0aW9uc1xuICovXG5leHBvcnQgY29uc3QgZ2V0U2VjdGlvbnMgPSBhc3luYyAoY2xhc3NJZCkgPT4ge1xuICAvLyBTaW11bGF0ZSBuZXR3b3JrIHJlcXVlc3RcbiAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpO1xuICBcbiAgbGV0IHNlY3Rpb25EYXRhID0gWy4uLm1vY2tTZWN0aW9uc107XG4gIFxuICBpZiAoY2xhc3NJZCkge1xuICAgIHNlY3Rpb25EYXRhID0gc2VjdGlvbkRhdGEuZmlsdGVyKHNlY3Rpb24gPT4gc2VjdGlvbi5jbGFzc0lkID09PSBwYXJzZUludChjbGFzc0lkKSk7XG4gIH1cbiAgXG4gIHJldHVybiBzZWN0aW9uRGF0YTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHVzZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyRGF0YSAtIFVzZXIgZGF0YVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSBDcmVhdGVkIHVzZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVVzZXIgPSBhc3luYyAodXNlckRhdGEpID0+IHtcbiAgLy8gU2ltdWxhdGUgbmV0d29yayByZXF1ZXN0XG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgXG4gIC8vIEdlbmVyYXRlIGEgbmV3IElEIChpbiBhIHJlYWwgYXBwLCB0aGlzIHdvdWxkIGNvbWUgZnJvbSB0aGUgYmFja2VuZClcbiAgY29uc3QgbmV3SWQgPSB1c2VyRGF0YS5yb2xlID09PSAnZmFjdWx0eScgXG4gICAgPyBNYXRoLm1heCguLi5tb2NrRmFjdWx0eS5tYXAoZiA9PiBmLmlkKSkgKyAxIFxuICAgIDogTWF0aC5tYXgoLi4ubW9ja1N0dWRlbnRzLm1hcChzID0+IHMuaWQpKSArIDE7XG4gIFxuICBjb25zdCBuZXdVc2VyID0ge1xuICAgIC4uLnVzZXJEYXRhLFxuICAgIGlkOiBuZXdJZCxcbiAgICBwYXNzd29yZF9oYXNoOiAnaGFzaGVkXycgKyB1c2VyRGF0YS5wYXNzd29yZCwgLy8gSW4gYSByZWFsIGFwcCwgcGFzc3dvcmQgd291bGQgYmUgaGFzaGVkIG9uIHRoZSBzZXJ2ZXJcbiAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIH07XG4gIFxuICAvLyBBZGQgdG8gdGhlIGFwcHJvcHJpYXRlIG1vY2sgZGF0YSBhcnJheVxuICBpZiAodXNlckRhdGEucm9sZSA9PT0gJ2ZhY3VsdHknKSB7XG4gICAgbW9ja0ZhY3VsdHkucHVzaChuZXdVc2VyKTtcbiAgfSBlbHNlIHtcbiAgICBtb2NrU3R1ZGVudHMucHVzaChuZXdVc2VyKTtcbiAgfVxuICBcbiAgcmV0dXJuIG5ld1VzZXI7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBleGlzdGluZyB1c2VyXG4gKiBAcGFyYW0ge251bWJlcn0gdXNlcklkIC0gVXNlciBJRFxuICogQHBhcmFtIHtPYmplY3R9IHVzZXJEYXRhIC0gVXBkYXRlZCB1c2VyIGRhdGFcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IC0gVXBkYXRlZCB1c2VyXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVVc2VyID0gYXN5bmMgKHVzZXJJZCwgdXNlckRhdGEpID0+IHtcbiAgLy8gU2ltdWxhdGUgbmV0d29yayByZXF1ZXN0XG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgXG4gIGNvbnN0IGlkID0gcGFyc2VJbnQodXNlcklkKTtcbiAgY29uc3QgaXNTdHVkZW50ID0gdXNlckRhdGEucm9sZSA9PT0gJ3N0dWRlbnQnO1xuICBcbiAgbGV0IHVzZXJJbmRleDtcbiAgbGV0IHVzZXI7XG4gIFxuICBpZiAoaXNTdHVkZW50KSB7XG4gICAgdXNlckluZGV4ID0gbW9ja1N0dWRlbnRzLmZpbmRJbmRleChzID0+IHMuaWQgPT09IGlkKTtcbiAgICBpZiAodXNlckluZGV4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKCdTdHVkZW50IG5vdCBmb3VuZCcpO1xuICAgIHVzZXIgPSBtb2NrU3R1ZGVudHNbdXNlckluZGV4XTtcbiAgfSBlbHNlIHtcbiAgICB1c2VySW5kZXggPSBtb2NrRmFjdWx0eS5maW5kSW5kZXgoZiA9PiBmLmlkID09PSBpZCk7XG4gICAgaWYgKHVzZXJJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcignRmFjdWx0eSBub3QgZm91bmQnKTtcbiAgICB1c2VyID0gbW9ja0ZhY3VsdHlbdXNlckluZGV4XTtcbiAgfVxuICBcbiAgLy8gVXBkYXRlIHVzZXIgZGF0YVxuICBjb25zdCB1cGRhdGVkVXNlciA9IHtcbiAgICAuLi51c2VyLFxuICAgIG5hbWU6IHVzZXJEYXRhLm5hbWUsXG4gICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLFxuICAgIGRlcGFydG1lbnRJZDogdXNlckRhdGEuZGVwYXJ0bWVudElkLFxuICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICB9O1xuICBcbiAgLy8gVXBkYXRlIHBhc3N3b3JkIGlmIHByb3ZpZGVkXG4gIGlmICh1c2VyRGF0YS5wYXNzd29yZCkge1xuICAgIHVwZGF0ZWRVc2VyLnBhc3N3b3JkX2hhc2ggPSAnaGFzaGVkXycgKyB1c2VyRGF0YS5wYXNzd29yZDtcbiAgfVxuICBcbiAgLy8gVXBkYXRlIHN0dWRlbnQtc3BlY2lmaWMgZmllbGRzXG4gIGlmIChpc1N0dWRlbnQpIHtcbiAgICB1cGRhdGVkVXNlci5jbGFzc0lkID0gdXNlckRhdGEuY2xhc3NJZDtcbiAgICB1cGRhdGVkVXNlci5zZWN0aW9uSWQgPSB1c2VyRGF0YS5zZWN0aW9uSWQ7XG4gICAgbW9ja1N0dWRlbnRzW3VzZXJJbmRleF0gPSB1cGRhdGVkVXNlcjtcbiAgfSBlbHNlIHtcbiAgICBtb2NrRmFjdWx0eVt1c2VySW5kZXhdID0gdXBkYXRlZFVzZXI7XG4gIH1cbiAgXG4gIHJldHVybiB1cGRhdGVkVXNlcjtcbn07XG5cbi8qKlxuICogRGVsZXRlIGEgdXNlclxuICogQHBhcmFtIHtudW1iZXJ9IHVzZXJJZCAtIFVzZXIgSURcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSAtIFN1Y2Nlc3Mgc3RhdHVzXG4gKi9cbmV4cG9ydCBjb25zdCBkZWxldGVVc2VyID0gYXN5bmMgKHVzZXJJZCkgPT4ge1xuICAvLyBTaW11bGF0ZSBuZXR3b3JrIHJlcXVlc3RcbiAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICBcbiAgY29uc3QgaWQgPSBwYXJzZUludCh1c2VySWQpO1xuICBcbiAgLy8gVHJ5IHRvIGZpbmQgYW5kIGRlbGV0ZSBmcm9tIHN0dWRlbnRzXG4gIGNvbnN0IHN0dWRlbnRJbmRleCA9IG1vY2tTdHVkZW50cy5maW5kSW5kZXgocyA9PiBzLmlkID09PSBpZCk7XG4gIGlmIChzdHVkZW50SW5kZXggIT09IC0xKSB7XG4gICAgbW9ja1N0dWRlbnRzLnNwbGljZShzdHVkZW50SW5kZXgsIDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIFxuICAvLyBUcnkgdG8gZmluZCBhbmQgZGVsZXRlIGZyb20gZmFjdWx0eVxuICBjb25zdCBmYWN1bHR5SW5kZXggPSBtb2NrRmFjdWx0eS5maW5kSW5kZXgoZiA9PiBmLmlkID09PSBpZCk7XG4gIGlmIChmYWN1bHR5SW5kZXggIT09IC0xKSB7XG4gICAgbW9ja0ZhY3VsdHkuc3BsaWNlKGZhY3VsdHlJbmRleCwgMSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgXG4gIHRocm93IG5ldyBFcnJvcignVXNlciBub3QgZm91bmQnKTtcbn07XG5cbi8vID09PT09PT09PT09IENPVVJTRVMgPT09PT09PT09PT1cblxuLyoqXG4gKiBHZXQgYWxsIGNvdXJzZXMgd2l0aCBvcHRpb25hbCBmaWx0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gcXVlcnlQYXJhbXMgLSBGaWx0ZXIgcGFyYW1ldGVyc1xuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fSAtIExpc3Qgb2YgY291cnNlc1xuICovXG5leHBvcnQgY29uc3QgZ2V0Q291cnNlcyA9IGFzeW5jIChxdWVyeVBhcmFtcyA9IHt9KSA9PiB7XG4gIC8vIFNpbXVsYXRlIG5ldHdvcmsgcmVxdWVzdFxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gIFxuICBjb25zdCB7IGRlcGFydG1lbnRJZCwgc2VhcmNoIH0gPSBxdWVyeVBhcmFtcztcbiAgXG4gIGxldCBjb3Vyc2VzID0gWy4uLm1vY2tDb3Vyc2VzXTtcbiAgXG4gIGlmIChkZXBhcnRtZW50SWQpIHtcbiAgICBjb3Vyc2VzID0gY291cnNlcy5maWx0ZXIoY291cnNlID0+IGNvdXJzZS5kZXBhcnRtZW50SWQgPT09IHBhcnNlSW50KGRlcGFydG1lbnRJZCkpO1xuICB9XG4gIFxuICBpZiAoc2VhcmNoKSB7XG4gICAgY29uc3Qgc2VhcmNoTG93ZXIgPSBzZWFyY2gudG9Mb3dlckNhc2UoKTtcbiAgICBjb3Vyc2VzID0gY291cnNlcy5maWx0ZXIoY291cnNlID0+IFxuICAgICAgY291cnNlLm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hMb3dlcikgfHwgXG4gICAgICBjb3Vyc2UuY291cnNlX2NvZGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hMb3dlcilcbiAgICApO1xuICB9XG4gIFxuICByZXR1cm4gY291cnNlcztcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGNvdXJzZVxuICogQHBhcmFtIHtPYmplY3R9IGNvdXJzZURhdGEgLSBDb3Vyc2UgZGF0YVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSBDcmVhdGVkIGNvdXJzZVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQ291cnNlID0gYXN5bmMgKGNvdXJzZURhdGEpID0+IHtcbiAgLy8gU2ltdWxhdGUgbmV0d29yayByZXF1ZXN0XG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgXG4gIGNvbnN0IG5ld0lkID0gTWF0aC5tYXgoLi4ubW9ja0NvdXJzZXMubWFwKGMgPT4gYy5pZCkpICsgMTtcbiAgXG4gIGNvbnN0IG5ld0NvdXJzZSA9IHtcbiAgICAuLi5jb3Vyc2VEYXRhLFxuICAgIGlkOiBuZXdJZCxcbiAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIH07XG4gIFxuICBtb2NrQ291cnNlcy5wdXNoKG5ld0NvdXJzZSk7XG4gIFxuICByZXR1cm4gbmV3Q291cnNlO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgYW4gZXhpc3RpbmcgY291cnNlXG4gKiBAcGFyYW0ge251bWJlcn0gY291cnNlSWQgLSBDb3Vyc2UgSURcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb3Vyc2VEYXRhIC0gVXBkYXRlZCBjb3Vyc2UgZGF0YVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSBVcGRhdGVkIGNvdXJzZVxuICovXG5leHBvcnQgY29uc3QgdXBkYXRlQ291cnNlID0gYXN5bmMgKGNvdXJzZUlkLCBjb3Vyc2VEYXRhKSA9PiB7XG4gIC8vIFNpbXVsYXRlIG5ldHdvcmsgcmVxdWVzdFxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gIFxuICBjb25zdCBpZCA9IHBhcnNlSW50KGNvdXJzZUlkKTtcbiAgY29uc3QgY291cnNlSW5kZXggPSBtb2NrQ291cnNlcy5maW5kSW5kZXgoYyA9PiBjLmlkID09PSBpZCk7XG4gIFxuICBpZiAoY291cnNlSW5kZXggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoJ0NvdXJzZSBub3QgZm91bmQnKTtcbiAgXG4gIGNvbnN0IGNvdXJzZSA9IG1vY2tDb3Vyc2VzW2NvdXJzZUluZGV4XTtcbiAgXG4gIGNvbnN0IHVwZGF0ZWRDb3Vyc2UgPSB7XG4gICAgLi4uY291cnNlLFxuICAgIC4uLmNvdXJzZURhdGEsXG4gICAgaWQsXG4gICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIH07XG4gIFxuICBtb2NrQ291cnNlc1tjb3Vyc2VJbmRleF0gPSB1cGRhdGVkQ291cnNlO1xuICBcbiAgcmV0dXJuIHVwZGF0ZWRDb3Vyc2U7XG59O1xuXG4vKipcbiAqIERlbGV0ZSBhIGNvdXJzZVxuICogQHBhcmFtIHtudW1iZXJ9IGNvdXJzZUlkIC0gQ291cnNlIElEXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gLSBTdWNjZXNzIHN0YXR1c1xuICovXG5leHBvcnQgY29uc3QgZGVsZXRlQ291cnNlID0gYXN5bmMgKGNvdXJzZUlkKSA9PiB7XG4gIC8vIFNpbXVsYXRlIG5ldHdvcmsgcmVxdWVzdFxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gIFxuICBjb25zdCBpZCA9IHBhcnNlSW50KGNvdXJzZUlkKTtcbiAgY29uc3QgY291cnNlSW5kZXggPSBtb2NrQ291cnNlcy5maW5kSW5kZXgoYyA9PiBjLmlkID09PSBpZCk7XG4gIFxuICBpZiAoY291cnNlSW5kZXggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoJ0NvdXJzZSBub3QgZm91bmQnKTtcbiAgXG4gIG1vY2tDb3Vyc2VzLnNwbGljZShjb3Vyc2VJbmRleCwgMSk7XG4gIFxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vID09PT09PT09PT09IFRJTUVUQUJMRSAvIFNDSEVEVUxFUyA9PT09PT09PT09PVxuXG4vKipcbiAqIEdldCBzY2hlZHVsZXMgd2l0aCBvcHRpb25hbCBmaWx0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gcXVlcnlQYXJhbXMgLSBGaWx0ZXIgcGFyYW1ldGVyc1xuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fSAtIExpc3Qgb2Ygc2NoZWR1bGVzXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRTY2hlZHVsZXMgPSBhc3luYyAocXVlcnlQYXJhbXMgPSB7fSkgPT4ge1xuICAvLyBTaW11bGF0ZSBuZXR3b3JrIHJlcXVlc3RcbiAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICBcbiAgY29uc3QgeyB2aWV3X3R5cGUsIGRlcGFydG1lbnRJZCwgY2xhc3NJZCwgc2VjdGlvbklkLCBmYWN1bHR5SWQsIGRheSB9ID0gcXVlcnlQYXJhbXM7XG4gIFxuICBsZXQgc2NoZWR1bGVzID0gWy4uLm1vY2tTY2hlZHVsZXNdO1xuICBcbiAgaWYgKGRheSkge1xuICAgIHNjaGVkdWxlcyA9IHNjaGVkdWxlcy5maWx0ZXIoc2NoZWR1bGUgPT4gc2NoZWR1bGUuZGF5X29mX3dlZWsgPT09IGRheSk7XG4gIH1cbiAgXG4gIGlmICh2aWV3X3R5cGUgPT09ICdzdHVkZW50Jykge1xuICAgIC8vIFN0dWRlbnQgdmlldyBmaWx0ZXJzXG4gICAgaWYgKGRlcGFydG1lbnRJZCAmJiAhY2xhc3NJZCkge1xuICAgICAgc2NoZWR1bGVzID0gc2NoZWR1bGVzLmZpbHRlcihzY2hlZHVsZSA9PiBcbiAgICAgICAgbW9ja0NsYXNzZXMuZmluZChjID0+IGMuaWQgPT09IHNjaGVkdWxlLmNsYXNzSWQpPy5kZXBhcnRtZW50SWQgPT09IHBhcnNlSW50KGRlcGFydG1lbnRJZClcbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIGlmIChjbGFzc0lkKSB7XG4gICAgICBzY2hlZHVsZXMgPSBzY2hlZHVsZXMuZmlsdGVyKHNjaGVkdWxlID0+IHNjaGVkdWxlLmNsYXNzSWQgPT09IHBhcnNlSW50KGNsYXNzSWQpKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHNlY3Rpb25JZCkge1xuICAgICAgc2NoZWR1bGVzID0gc2NoZWR1bGVzLmZpbHRlcihzY2hlZHVsZSA9PiBzY2hlZHVsZS5zZWN0aW9uSWQgPT09IHBhcnNlSW50KHNlY3Rpb25JZCkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBGYWN1bHR5IHZpZXcgZmlsdGVyc1xuICAgIGlmIChmYWN1bHR5SWQpIHtcbiAgICAgIHNjaGVkdWxlcyA9IHNjaGVkdWxlcy5maWx0ZXIoc2NoZWR1bGUgPT4gc2NoZWR1bGUuZmFjdWx0eUlkID09PSBwYXJzZUludChmYWN1bHR5SWQpKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGRlcGFydG1lbnRJZCkge1xuICAgICAgc2NoZWR1bGVzID0gc2NoZWR1bGVzLmZpbHRlcihzY2hlZHVsZSA9PiBcbiAgICAgICAgbW9ja0ZhY3VsdHkuZmluZChmID0+IGYuaWQgPT09IHNjaGVkdWxlLmZhY3VsdHlJZCk/LmRlcGFydG1lbnRJZCA9PT0gcGFyc2VJbnQoZGVwYXJ0bWVudElkKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEFkZCByZWxhdGVkIGRhdGEgKGluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3b3VsZCBiZSBkb25lIHdpdGggam9pbnMgaW4gdGhlIGRhdGFiYXNlIHF1ZXJ5KVxuICBjb25zdCBzY2hlZHVsZXNXaXRoUmVsYXRlZCA9IHNjaGVkdWxlcy5tYXAoc2NoZWR1bGUgPT4ge1xuICAgIGNvbnN0IGNvdXJzZSA9IG1vY2tDb3Vyc2VzLmZpbmQoYyA9PiBjLmlkID09PSBzY2hlZHVsZS5jb3Vyc2VJZCk7XG4gICAgY29uc3QgZmFjdWx0eSA9IG1vY2tGYWN1bHR5LmZpbmQoZiA9PiBmLmlkID09PSBzY2hlZHVsZS5mYWN1bHR5SWQpO1xuICAgIGNvbnN0IGNsYXNzSW5mbyA9IG1vY2tDbGFzc2VzLmZpbmQoYyA9PiBjLmlkID09PSBzY2hlZHVsZS5jbGFzc0lkKTtcbiAgICBjb25zdCBzZWN0aW9uID0gbW9ja1NlY3Rpb25zLmZpbmQocyA9PiBzLmlkID09PSBzY2hlZHVsZS5zZWN0aW9uSWQpO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAuLi5zY2hlZHVsZSxcbiAgICAgIGNvdXJzZSxcbiAgICAgIGZhY3VsdHksXG4gICAgICBjbGFzczogY2xhc3NJbmZvLFxuICAgICAgc2VjdGlvblxuICAgIH07XG4gIH0pO1xuICBcbiAgcmV0dXJuIHNjaGVkdWxlc1dpdGhSZWxhdGVkO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc2NoZWR1bGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlZHVsZURhdGEgLSBTY2hlZHVsZSBkYXRhXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIENyZWF0ZWQgc2NoZWR1bGVcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVNjaGVkdWxlID0gYXN5bmMgKHNjaGVkdWxlRGF0YSkgPT4ge1xuICAvLyBTaW11bGF0ZSBuZXR3b3JrIHJlcXVlc3RcbiAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICBcbiAgY29uc3QgbmV3SWQgPSBNYXRoLm1heCguLi5tb2NrU2NoZWR1bGVzLm1hcChzID0+IHMuaWQpKSArIDE7XG4gIFxuICBjb25zdCBuZXdTY2hlZHVsZSA9IHtcbiAgICAuLi5zY2hlZHVsZURhdGEsXG4gICAgaWQ6IG5ld0lkXG4gIH07XG4gIFxuICBtb2NrU2NoZWR1bGVzLnB1c2gobmV3U2NoZWR1bGUpO1xuICBcbiAgLy8gUmV0dXJuIHdpdGggcmVsYXRlZCBkYXRhXG4gIGNvbnN0IGNvdXJzZSA9IG1vY2tDb3Vyc2VzLmZpbmQoYyA9PiBjLmlkID09PSBuZXdTY2hlZHVsZS5jb3Vyc2VJZCk7XG4gIGNvbnN0IGZhY3VsdHkgPSBtb2NrRmFjdWx0eS5maW5kKGYgPT4gZi5pZCA9PT0gbmV3U2NoZWR1bGUuZmFjdWx0eUlkKTtcbiAgY29uc3QgY2xhc3NJbmZvID0gbW9ja0NsYXNzZXMuZmluZChjID0+IGMuaWQgPT09IG5ld1NjaGVkdWxlLmNsYXNzSWQpO1xuICBjb25zdCBzZWN0aW9uID0gbW9ja1NlY3Rpb25zLmZpbmQocyA9PiBzLmlkID09PSBuZXdTY2hlZHVsZS5zZWN0aW9uSWQpO1xuICBcbiAgcmV0dXJuIHtcbiAgICAuLi5uZXdTY2hlZHVsZSxcbiAgICBjb3Vyc2UsXG4gICAgZmFjdWx0eSxcbiAgICBjbGFzczogY2xhc3NJbmZvLFxuICAgIHNlY3Rpb25cbiAgfTtcbn07XG5cbi8qKlxuICogVXBkYXRlIGEgc2NoZWR1bGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzY2hlZHVsZUlkIC0gU2NoZWR1bGUgSURcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlZHVsZURhdGEgLSBVcGRhdGVkIHNjaGVkdWxlIGRhdGFcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IC0gVXBkYXRlZCBzY2hlZHVsZVxuICovXG5leHBvcnQgY29uc3QgdXBkYXRlU2NoZWR1bGUgPSBhc3luYyAoc2NoZWR1bGVJZCwgc2NoZWR1bGVEYXRhKSA9PiB7XG4gIC8vIFNpbXVsYXRlIG5ldHdvcmsgcmVxdWVzdFxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gIFxuICBjb25zdCBpZCA9IHBhcnNlSW50KHNjaGVkdWxlSWQpO1xuICBjb25zdCBzY2hlZHVsZUluZGV4ID0gbW9ja1NjaGVkdWxlcy5maW5kSW5kZXgocyA9PiBzLmlkID09PSBpZCk7XG4gIFxuICBpZiAoc2NoZWR1bGVJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcignU2NoZWR1bGUgbm90IGZvdW5kJyk7XG4gIFxuICBjb25zdCBzY2hlZHVsZSA9IG1vY2tTY2hlZHVsZXNbc2NoZWR1bGVJbmRleF07XG4gIFxuICBjb25zdCB1cGRhdGVkU2NoZWR1bGUgPSB7XG4gICAgLi4uc2NoZWR1bGUsXG4gICAgLi4uc2NoZWR1bGVEYXRhLFxuICAgIGlkXG4gIH07XG4gIFxuICBtb2NrU2NoZWR1bGVzW3NjaGVkdWxlSW5kZXhdID0gdXBkYXRlZFNjaGVkdWxlO1xuICBcbiAgLy8gUmV0dXJuIHdpdGggcmVsYXRlZCBkYXRhXG4gIGNvbnN0IGNvdXJzZSA9IG1vY2tDb3Vyc2VzLmZpbmQoYyA9PiBjLmlkID09PSB1cGRhdGVkU2NoZWR1bGUuY291cnNlSWQpO1xuICBjb25zdCBmYWN1bHR5ID0gbW9ja0ZhY3VsdHkuZmluZChmID0+IGYuaWQgPT09IHVwZGF0ZWRTY2hlZHVsZS5mYWN1bHR5SWQpO1xuICBjb25zdCBjbGFzc0luZm8gPSBtb2NrQ2xhc3Nlcy5maW5kKGMgPT4gYy5pZCA9PT0gdXBkYXRlZFNjaGVkdWxlLmNsYXNzSWQpO1xuICBjb25zdCBzZWN0aW9uID0gbW9ja1NlY3Rpb25zLmZpbmQocyA9PiBzLmlkID09PSB1cGRhdGVkU2NoZWR1bGUuc2VjdGlvbklkKTtcbiAgXG4gIHJldHVybiB7XG4gICAgLi4udXBkYXRlZFNjaGVkdWxlLFxuICAgIGNvdXJzZSxcbiAgICBmYWN1bHR5LFxuICAgIGNsYXNzOiBjbGFzc0luZm8sXG4gICAgc2VjdGlvblxuICB9O1xufTtcblxuLyoqXG4gKiBEZWxldGUgYSBzY2hlZHVsZVxuICogQHBhcmFtIHtudW1iZXJ9IHNjaGVkdWxlSWQgLSBTY2hlZHVsZSBJRFxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IC0gU3VjY2VzcyBzdGF0dXNcbiAqL1xuZXhwb3J0IGNvbnN0IGRlbGV0ZVNjaGVkdWxlID0gYXN5bmMgKHNjaGVkdWxlSWQpID0+IHtcbiAgLy8gU2ltdWxhdGUgbmV0d29yayByZXF1ZXN0XG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgXG4gIGNvbnN0IGlkID0gcGFyc2VJbnQoc2NoZWR1bGVJZCk7XG4gIGNvbnN0IHNjaGVkdWxlSW5kZXggPSBtb2NrU2NoZWR1bGVzLmZpbmRJbmRleChzID0+IHMuaWQgPT09IGlkKTtcbiAgXG4gIGlmIChzY2hlZHVsZUluZGV4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKCdTY2hlZHVsZSBub3QgZm91bmQnKTtcbiAgXG4gIG1vY2tTY2hlZHVsZXMuc3BsaWNlKHNjaGVkdWxlSW5kZXgsIDEpO1xuICBcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyA9PT09PT09PT09PSBBVFRFTkRBTkNFID09PT09PT09PT09XG5cbi8qKlxuICogR2V0IGF0dGVuZGFuY2Ugd2l0aCBvcHRpb25hbCBmaWx0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gcXVlcnlQYXJhbXMgLSBGaWx0ZXIgcGFyYW1ldGVyc1xuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fSAtIExpc3Qgb2YgYXR0ZW5kYW5jZSByZWNvcmRzXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRBdHRlbmRhbmNlID0gYXN5bmMgKHF1ZXJ5UGFyYW1zID0ge30pID0+IHtcbiAgLy8gU2ltdWxhdGUgbmV0d29yayByZXF1ZXN0XG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgXG4gIGNvbnN0IHsgdmlld190eXBlLCBkZXBhcnRtZW50SWQsIGNsYXNzSWQsIHNlY3Rpb25JZCwgY291cnNlSWQsIGZhY3VsdHlJZCwgZGF0ZSwgc3RhdHVzIH0gPSBxdWVyeVBhcmFtcztcbiAgXG4gIGxldCBhdHRlbmRhbmNlID0gWy4uLm1vY2tBdHRlbmRhbmNlXTtcbiAgXG4gIGlmIChkYXRlKSB7XG4gICAgY29uc3QgZGF0ZU9iaiA9IG5ldyBEYXRlKGRhdGUpO1xuICAgIGNvbnN0IHllYXIgPSBkYXRlT2JqLmdldEZ1bGxZZWFyKCk7XG4gICAgY29uc3QgbW9udGggPSBkYXRlT2JqLmdldE1vbnRoKCk7XG4gICAgY29uc3QgZGF5ID0gZGF0ZU9iai5nZXREYXRlKCk7XG4gICAgXG4gICAgYXR0ZW5kYW5jZSA9IGF0dGVuZGFuY2UuZmlsdGVyKGEgPT4ge1xuICAgICAgY29uc3QgcmVjb3JkRGF0ZSA9IG5ldyBEYXRlKGEuZGF0ZSk7XG4gICAgICByZXR1cm4gcmVjb3JkRGF0ZS5nZXRGdWxsWWVhcigpID09PSB5ZWFyICYmIFxuICAgICAgICAgICAgIHJlY29yZERhdGUuZ2V0TW9udGgoKSA9PT0gbW9udGggJiYgXG4gICAgICAgICAgICAgcmVjb3JkRGF0ZS5nZXREYXRlKCkgPT09IGRheTtcbiAgICB9KTtcbiAgfVxuICBcbiAgaWYgKHN0YXR1cykge1xuICAgIGF0dGVuZGFuY2UgPSBhdHRlbmRhbmNlLmZpbHRlcihhID0+IGEuc3RhdHVzID09PSBzdGF0dXMpO1xuICB9XG4gIFxuICBpZiAodmlld190eXBlID09PSAnc3R1ZGVudCcpIHtcbiAgICAvLyBTdHVkZW50IGF0dGVuZGFuY2UgZmlsdGVyc1xuICAgIGlmIChjb3Vyc2VJZCkge1xuICAgICAgYXR0ZW5kYW5jZSA9IGF0dGVuZGFuY2UuZmlsdGVyKGEgPT4gYS5jb3Vyc2VJZCA9PT0gcGFyc2VJbnQoY291cnNlSWQpKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGRlcGFydG1lbnRJZCB8fCBjbGFzc0lkIHx8IHNlY3Rpb25JZCkge1xuICAgICAgYXR0ZW5kYW5jZSA9IGF0dGVuZGFuY2UuZmlsdGVyKGEgPT4ge1xuICAgICAgICBjb25zdCBzdHVkZW50ID0gbW9ja1N0dWRlbnRzLmZpbmQocyA9PiBzLmlkID09PSBhLnN0dWRlbnRJZCk7XG4gICAgICAgIGlmICghc3R1ZGVudCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgaWYgKGRlcGFydG1lbnRJZCAmJiBzdHVkZW50LmRlcGFydG1lbnRJZCAhPT0gcGFyc2VJbnQoZGVwYXJ0bWVudElkKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoY2xhc3NJZCAmJiBzdHVkZW50LmNsYXNzSWQgIT09IHBhcnNlSW50KGNsYXNzSWQpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChzZWN0aW9uSWQgJiYgc3R1ZGVudC5zZWN0aW9uSWQgIT09IHBhcnNlSW50KHNlY3Rpb25JZCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEZhY3VsdHkgdmlldyB3b3VsZCBiZSBpbXBsZW1lbnRlZCBkaWZmZXJlbnRseVxuICAgIC8vIEZvciBub3csIHdlJ2xsIHJldHVybiBlbXB0eSBmb3IgZmFjdWx0eSB2aWV3IHRvIG1hdGNoIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uXG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIFxuICAvLyBBZGQgcmVsYXRlZCBkYXRhXG4gIGNvbnN0IGF0dGVuZGFuY2VXaXRoUmVsYXRlZCA9IGF0dGVuZGFuY2UubWFwKHJlY29yZCA9PiB7XG4gICAgY29uc3Qgc3R1ZGVudCA9IG1vY2tTdHVkZW50cy5maW5kKHMgPT4gcy5pZCA9PT0gcmVjb3JkLnN0dWRlbnRJZCk7XG4gICAgY29uc3QgY291cnNlID0gbW9ja0NvdXJzZXMuZmluZChjID0+IGMuaWQgPT09IHJlY29yZC5jb3Vyc2VJZCk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlY29yZCxcbiAgICAgIHN0dWRlbnQsXG4gICAgICBjb3Vyc2VcbiAgICB9O1xuICB9KTtcbiAgXG4gIHJldHVybiBhdHRlbmRhbmNlV2l0aFJlbGF0ZWQ7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBhdHRlbmRhbmNlIHN0YXR1c1xuICogQHBhcmFtIHtudW1iZXJ9IGF0dGVuZGFuY2VJZCAtIEF0dGVuZGFuY2UgSURcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVXBkYXRlIGRhdGEgKHN0YXR1cylcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IC0gVXBkYXRlZCBhdHRlbmRhbmNlIHJlY29yZFxuICovXG5leHBvcnQgY29uc3QgdXBkYXRlQXR0ZW5kYW5jZSA9IGFzeW5jIChhdHRlbmRhbmNlSWQsIGRhdGEpID0+IHtcbiAgLy8gU2ltdWxhdGUgbmV0d29yayByZXF1ZXN0XG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgXG4gIGNvbnN0IGlkID0gcGFyc2VJbnQoYXR0ZW5kYW5jZUlkKTtcbiAgY29uc3QgYXR0ZW5kYW5jZUluZGV4ID0gbW9ja0F0dGVuZGFuY2UuZmluZEluZGV4KGEgPT4gYS5pZCA9PT0gaWQpO1xuICBcbiAgaWYgKGF0dGVuZGFuY2VJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcignQXR0ZW5kYW5jZSByZWNvcmQgbm90IGZvdW5kJyk7XG4gIFxuICBjb25zdCBhdHRlbmRhbmNlID0gbW9ja0F0dGVuZGFuY2VbYXR0ZW5kYW5jZUluZGV4XTtcbiAgXG4gIGNvbnN0IHVwZGF0ZWRBdHRlbmRhbmNlID0ge1xuICAgIC4uLmF0dGVuZGFuY2UsXG4gICAgc3RhdHVzOiBkYXRhLnN0YXR1c1xuICB9O1xuICBcbiAgbW9ja0F0dGVuZGFuY2VbYXR0ZW5kYW5jZUluZGV4XSA9IHVwZGF0ZWRBdHRlbmRhbmNlO1xuICBcbiAgLy8gUmV0dXJuIHdpdGggcmVsYXRlZCBkYXRhXG4gIGNvbnN0IHN0dWRlbnQgPSBtb2NrU3R1ZGVudHMuZmluZChzID0+IHMuaWQgPT09IHVwZGF0ZWRBdHRlbmRhbmNlLnN0dWRlbnRJZCk7XG4gIGNvbnN0IGNvdXJzZSA9IG1vY2tDb3Vyc2VzLmZpbmQoYyA9PiBjLmlkID09PSB1cGRhdGVkQXR0ZW5kYW5jZS5jb3Vyc2VJZCk7XG4gIFxuICByZXR1cm4ge1xuICAgIC4uLnVwZGF0ZWRBdHRlbmRhbmNlLFxuICAgIHN0dWRlbnQsXG4gICAgY291cnNlXG4gIH07XG59O1xuXG4vKipcbiAqIEdldCBhdHRlbmRhbmNlIGFuYWx5dGljc1xuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSBBdHRlbmRhbmNlIGFuYWx5dGljcyBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRBdHRlbmRhbmNlQW5hbHl0aWNzID0gYXN5bmMgKCkgPT4ge1xuICAvLyBTaW11bGF0ZSBuZXR3b3JrIHJlcXVlc3RcbiAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICBcbiAgcmV0dXJuIG1vY2tBdHRlbmRhbmNlQW5hbHl0aWNzO1xufTtcblxuLy8gPT09PT09PT09PT0gRVZFTlRTID09PT09PT09PT09XG5cbi8qKlxuICogR2V0IGV2ZW50cyB3aXRoIG9wdGlvbmFsIGZpbHRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBxdWVyeVBhcmFtcyAtIEZpbHRlciBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59IC0gTGlzdCBvZiBldmVudHNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEV2ZW50cyA9IGFzeW5jIChxdWVyeVBhcmFtcyA9IHt9KSA9PiB7XG4gIC8vIFNpbXVsYXRlIG5ldHdvcmsgcmVxdWVzdFxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gIFxuICBjb25zdCB7IGZyb21fZGF0ZSwgdG9fZGF0ZSwgYXVkaWVuY2VfdHlwZSB9ID0gcXVlcnlQYXJhbXM7XG4gIFxuICBsZXQgZXZlbnRzID0gWy4uLm1vY2tFdmVudHNdO1xuICBcbiAgaWYgKGZyb21fZGF0ZSkge1xuICAgIGNvbnN0IGZyb21EYXRlID0gbmV3IERhdGUoZnJvbV9kYXRlKTtcbiAgICBldmVudHMgPSBldmVudHMuZmlsdGVyKGV2ZW50ID0+IG5ldyBEYXRlKGV2ZW50LmV2ZW50X2RhdGUpID49IGZyb21EYXRlKTtcbiAgfVxuICBcbiAgaWYgKHRvX2RhdGUpIHtcbiAgICBjb25zdCB0b0RhdGUgPSBuZXcgRGF0ZSh0b19kYXRlKTtcbiAgICBldmVudHMgPSBldmVudHMuZmlsdGVyKGV2ZW50ID0+IG5ldyBEYXRlKGV2ZW50LmV2ZW50X2RhdGUpIDw9IHRvRGF0ZSk7XG4gIH1cbiAgXG4gIC8vIFRvZG86IEFkZCBhdWRpZW5jZV90eXBlIGZpbHRlcmluZyBpZiBuZWVkZWRcbiAgXG4gIHJldHVybiBldmVudHM7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RGF0YSAtIEV2ZW50IGRhdGFcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IC0gQ3JlYXRlZCBldmVudFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRXZlbnQgPSBhc3luYyAoZXZlbnREYXRhKSA9PiB7XG4gIC8vIFNpbXVsYXRlIG5ldHdvcmsgcmVxdWVzdFxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gIFxuICBjb25zdCBuZXdJZCA9IE1hdGgubWF4KC4uLm1vY2tFdmVudHMubWFwKGUgPT4gZS5pZCkpICsgMTtcbiAgXG4gIGNvbnN0IG5ld0V2ZW50ID0ge1xuICAgIC4uLmV2ZW50RGF0YSxcbiAgICBpZDogbmV3SWQsXG4gICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICB9O1xuICBcbiAgbW9ja0V2ZW50cy5wdXNoKG5ld0V2ZW50KTtcbiAgXG4gIHJldHVybiBuZXdFdmVudDtcbn07XG5cbi8qKlxuICogVXBkYXRlIGFuIGV2ZW50XG4gKiBAcGFyYW0ge251bWJlcn0gZXZlbnRJZCAtIEV2ZW50IElEXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnREYXRhIC0gVXBkYXRlZCBldmVudCBkYXRhXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIFVwZGF0ZWQgZXZlbnRcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZUV2ZW50ID0gYXN5bmMgKGV2ZW50SWQsIGV2ZW50RGF0YSkgPT4ge1xuICAvLyBTaW11bGF0ZSBuZXR3b3JrIHJlcXVlc3RcbiAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICBcbiAgY29uc3QgaWQgPSBwYXJzZUludChldmVudElkKTtcbiAgY29uc3QgZXZlbnRJbmRleCA9IG1vY2tFdmVudHMuZmluZEluZGV4KGUgPT4gZS5pZCA9PT0gaWQpO1xuICBcbiAgaWYgKGV2ZW50SW5kZXggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IG5vdCBmb3VuZCcpO1xuICBcbiAgY29uc3QgZXZlbnQgPSBtb2NrRXZlbnRzW2V2ZW50SW5kZXhdO1xuICBcbiAgY29uc3QgdXBkYXRlZEV2ZW50ID0ge1xuICAgIC4uLmV2ZW50LFxuICAgIC4uLmV2ZW50RGF0YSxcbiAgICBpZCxcbiAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgfTtcbiAgXG4gIG1vY2tFdmVudHNbZXZlbnRJbmRleF0gPSB1cGRhdGVkRXZlbnQ7XG4gIFxuICByZXR1cm4gdXBkYXRlZEV2ZW50O1xufTtcblxuLyoqXG4gKiBEZWxldGUgYW4gZXZlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBldmVudElkIC0gRXZlbnQgSURcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSAtIFN1Y2Nlc3Mgc3RhdHVzXG4gKi9cbmV4cG9ydCBjb25zdCBkZWxldGVFdmVudCA9IGFzeW5jIChldmVudElkKSA9PiB7XG4gIC8vIFNpbXVsYXRlIG5ldHdvcmsgcmVxdWVzdFxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gIFxuICBjb25zdCBpZCA9IHBhcnNlSW50KGV2ZW50SWQpO1xuICBjb25zdCBldmVudEluZGV4ID0gbW9ja0V2ZW50cy5maW5kSW5kZXgoZSA9PiBlLmlkID09PSBpZCk7XG4gIFxuICBpZiAoZXZlbnRJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcignRXZlbnQgbm90IGZvdW5kJyk7XG4gIFxuICBtb2NrRXZlbnRzLnNwbGljZShldmVudEluZGV4LCAxKTtcbiAgXG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gPT09PT09PT09PT0gSU5WT0lDRVMgPT09PT09PT09PT1cblxuLyoqXG4gKiBHZXQgaW52b2ljZXMgd2l0aCBvcHRpb25hbCBmaWx0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gcXVlcnlQYXJhbXMgLSBGaWx0ZXIgcGFyYW1ldGVyc1xuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fSAtIExpc3Qgb2YgaW52b2ljZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEludm9pY2VzID0gYXN5bmMgKHF1ZXJ5UGFyYW1zID0ge30pID0+IHtcbiAgLy8gU2ltdWxhdGUgbmV0d29yayByZXF1ZXN0XG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgXG4gIGNvbnN0IHsgc3R1ZGVudElkLCBwYWlkLCBmcm9tX2RhdGUsIHRvX2RhdGUgfSA9IHF1ZXJ5UGFyYW1zO1xuICBcbiAgbGV0IGludm9pY2VzID0gWy4uLm1vY2tJbnZvaWNlc107XG4gIFxuICBpZiAoc3R1ZGVudElkKSB7XG4gICAgaW52b2ljZXMgPSBpbnZvaWNlcy5maWx0ZXIoaW52b2ljZSA9PiBpbnZvaWNlLnN0dWRlbnRJZCA9PT0gcGFyc2VJbnQoc3R1ZGVudElkKSk7XG4gIH1cbiAgXG4gIGlmIChwYWlkICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBpc1BhaWQgPSBwYWlkID09PSAndHJ1ZScgfHwgcGFpZCA9PT0gdHJ1ZTtcbiAgICBpbnZvaWNlcyA9IGludm9pY2VzLmZpbHRlcihpbnZvaWNlID0+IGludm9pY2UucGFpZCA9PT0gaXNQYWlkKTtcbiAgfVxuICBcbiAgaWYgKGZyb21fZGF0ZSkge1xuICAgIGNvbnN0IGZyb21EYXRlID0gbmV3IERhdGUoZnJvbV9kYXRlKTtcbiAgICBpbnZvaWNlcyA9IGludm9pY2VzLmZpbHRlcihpbnZvaWNlID0+IG5ldyBEYXRlKGludm9pY2UuZ2VuZXJhdGVkX2F0KSA+PSBmcm9tRGF0ZSk7XG4gIH1cbiAgXG4gIGlmICh0b19kYXRlKSB7XG4gICAgY29uc3QgdG9EYXRlID0gbmV3IERhdGUodG9fZGF0ZSk7XG4gICAgaW52b2ljZXMgPSBpbnZvaWNlcy5maWx0ZXIoaW52b2ljZSA9PiBuZXcgRGF0ZShpbnZvaWNlLmdlbmVyYXRlZF9hdCkgPD0gdG9EYXRlKTtcbiAgfVxuICBcbiAgLy8gQWRkIHN0dWRlbnQgZGF0YSB0byBlYWNoIGludm9pY2VcbiAgY29uc3QgaW52b2ljZXNXaXRoU3R1ZGVudHMgPSBpbnZvaWNlcy5tYXAoaW52b2ljZSA9PiB7XG4gICAgY29uc3Qgc3R1ZGVudCA9IG1vY2tTdHVkZW50cy5maW5kKHMgPT4gcy5pZCA9PT0gaW52b2ljZS5zdHVkZW50SWQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5pbnZvaWNlLFxuICAgICAgc3R1ZGVudFxuICAgIH07XG4gIH0pO1xuICBcbiAgcmV0dXJuIGludm9pY2VzV2l0aFN0dWRlbnRzO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW52b2ljZVxuICogQHBhcmFtIHtPYmplY3R9IGludm9pY2VEYXRhIC0gSW52b2ljZSBkYXRhXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIENyZWF0ZWQgaW52b2ljZVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlSW52b2ljZSA9IGFzeW5jIChpbnZvaWNlRGF0YSkgPT4ge1xuICAvLyBTaW11bGF0ZSBuZXR3b3JrIHJlcXVlc3RcbiAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICBcbiAgY29uc3QgbmV3SWQgPSBNYXRoLm1heCguLi5tb2NrSW52b2ljZXMubWFwKGkgPT4gaS5pZCkpICsgMTtcbiAgXG4gIC8vIEdlbmVyYXRlIGludm9pY2UgbnVtYmVyXG4gIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgY29uc3QgaW52b2ljZU51bWJlciA9IGBJTlYtJHt0b2RheS5nZXRGdWxsWWVhcigpfS0ke1N0cmluZyhuZXdJZCkucGFkU3RhcnQoMywgJzAnKX1gO1xuICBcbiAgY29uc3QgbmV3SW52b2ljZSA9IHtcbiAgICAuLi5pbnZvaWNlRGF0YSxcbiAgICBpZDogbmV3SWQsXG4gICAgaW52b2ljZV9udW1iZXI6IGludm9pY2VOdW1iZXIsXG4gICAgcGFpZDogZmFsc2UsXG4gICAgZ2VuZXJhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIH07XG4gIFxuICBtb2NrSW52b2ljZXMucHVzaChuZXdJbnZvaWNlKTtcbiAgXG4gIC8vIEFkZCBzdHVkZW50IGRhdGFcbiAgY29uc3Qgc3R1ZGVudCA9IG1vY2tTdHVkZW50cy5maW5kKHMgPT4gcy5pZCA9PT0gbmV3SW52b2ljZS5zdHVkZW50SWQpO1xuICBcbiAgcmV0dXJuIHtcbiAgICAuLi5uZXdJbnZvaWNlLFxuICAgIHN0dWRlbnRcbiAgfTtcbn07XG5cbi8qKlxuICogVXBkYXRlIGFuIGludm9pY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnZvaWNlSWQgLSBJbnZvaWNlIElEXG4gKiBAcGFyYW0ge09iamVjdH0gaW52b2ljZURhdGEgLSBVcGRhdGVkIGludm9pY2UgZGF0YVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSBVcGRhdGVkIGludm9pY2VcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZUludm9pY2UgPSBhc3luYyAoaW52b2ljZUlkLCBpbnZvaWNlRGF0YSkgPT4ge1xuICAvLyBTaW11bGF0ZSBuZXR3b3JrIHJlcXVlc3RcbiAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICBcbiAgY29uc3QgaWQgPSBwYXJzZUludChpbnZvaWNlSWQpO1xuICBjb25zdCBpbnZvaWNlSW5kZXggPSBtb2NrSW52b2ljZXMuZmluZEluZGV4KGkgPT4gaS5pZCA9PT0gaWQpO1xuICBcbiAgaWYgKGludm9pY2VJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcignSW52b2ljZSBub3QgZm91bmQnKTtcbiAgXG4gIGNvbnN0IGludm9pY2UgPSBtb2NrSW52b2ljZXNbaW52b2ljZUluZGV4XTtcbiAgXG4gIGNvbnN0IHVwZGF0ZWRJbnZvaWNlID0ge1xuICAgIC4uLmludm9pY2UsXG4gICAgLi4uaW52b2ljZURhdGEsXG4gICAgaWQsXG4gICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIH07XG4gIFxuICBtb2NrSW52b2ljZXNbaW52b2ljZUluZGV4XSA9IHVwZGF0ZWRJbnZvaWNlO1xuICBcbiAgLy8gQWRkIHN0dWRlbnQgZGF0YVxuICBjb25zdCBzdHVkZW50ID0gbW9ja1N0dWRlbnRzLmZpbmQocyA9PiBzLmlkID09PSB1cGRhdGVkSW52b2ljZS5zdHVkZW50SWQpO1xuICBcbiAgcmV0dXJuIHtcbiAgICAuLi51cGRhdGVkSW52b2ljZSxcbiAgICBzdHVkZW50XG4gIH07XG59O1xuXG4vKipcbiAqIERlbGV0ZSBhbiBpbnZvaWNlXG4gKiBAcGFyYW0ge251bWJlcn0gaW52b2ljZUlkIC0gSW52b2ljZSBJRFxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IC0gU3VjY2VzcyBzdGF0dXNcbiAqL1xuZXhwb3J0IGNvbnN0IGRlbGV0ZUludm9pY2UgPSBhc3luYyAoaW52b2ljZUlkKSA9PiB7XG4gIC8vIFNpbXVsYXRlIG5ldHdvcmsgcmVxdWVzdFxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gIFxuICBjb25zdCBpZCA9IHBhcnNlSW50KGludm9pY2VJZCk7XG4gIGNvbnN0IGludm9pY2VJbmRleCA9IG1vY2tJbnZvaWNlcy5maW5kSW5kZXgoaSA9PiBpLmlkID09PSBpZCk7XG4gIFxuICBpZiAoaW52b2ljZUluZGV4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKCdJbnZvaWNlIG5vdCBmb3VuZCcpO1xuICBcbiAgbW9ja0ludm9pY2VzLnNwbGljZShpbnZvaWNlSW5kZXgsIDEpO1xuICBcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIE1hcmsgYW4gaW52b2ljZSBhcyBwYWlkXG4gKiBAcGFyYW0ge251bWJlcn0gaW52b2ljZUlkIC0gSW52b2ljZSBJRFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSBVcGRhdGVkIGludm9pY2VcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcmtJbnZvaWNlUGFpZCA9IGFzeW5jIChpbnZvaWNlSWQpID0+IHtcbiAgLy8gU2ltdWxhdGUgbmV0d29yayByZXF1ZXN0XG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgXG4gIGNvbnN0IGlkID0gcGFyc2VJbnQoaW52b2ljZUlkKTtcbiAgY29uc3QgaW52b2ljZUluZGV4ID0gbW9ja0ludm9pY2VzLmZpbmRJbmRleChpID0+IGkuaWQgPT09IGlkKTtcbiAgXG4gIGlmIChpbnZvaWNlSW5kZXggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoJ0ludm9pY2Ugbm90IGZvdW5kJyk7XG4gIFxuICBjb25zdCBpbnZvaWNlID0gbW9ja0ludm9pY2VzW2ludm9pY2VJbmRleF07XG4gIFxuICBjb25zdCB1cGRhdGVkSW52b2ljZSA9IHtcbiAgICAuLi5pbnZvaWNlLFxuICAgIHBhaWQ6IHRydWUsXG4gICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIH07XG4gIFxuICBtb2NrSW52b2ljZXNbaW52b2ljZUluZGV4XSA9IHVwZGF0ZWRJbnZvaWNlO1xuICBcbiAgLy8gQWRkIHN0dWRlbnQgZGF0YVxuICBjb25zdCBzdHVkZW50ID0gbW9ja1N0dWRlbnRzLmZpbmQocyA9PiBzLmlkID09PSB1cGRhdGVkSW52b2ljZS5zdHVkZW50SWQpO1xuICBcbiAgcmV0dXJuIHtcbiAgICAuLi51cGRhdGVkSW52b2ljZSxcbiAgICBzdHVkZW50XG4gIH07XG59O1xuXG4vLyA9PT09PT09PT09PSBNRVNTQUdFUyA9PT09PT09PT09PVxuXG4vKipcbiAqIEdldCBtZXNzYWdlcyB3aXRoIG9wdGlvbmFsIGZpbHRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBxdWVyeVBhcmFtcyAtIEZpbHRlciBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59IC0gTGlzdCBvZiBtZXNzYWdlc1xuICovXG5leHBvcnQgY29uc3QgZ2V0TWVzc2FnZXMgPSBhc3luYyAocXVlcnlQYXJhbXMgPSB7fSkgPT4ge1xuICAvLyBTaW11bGF0ZSBuZXR3b3JrIHJlcXVlc3RcbiAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICBcbiAgY29uc3QgeyBmaWx0ZXIgfSA9IHF1ZXJ5UGFyYW1zO1xuICBcbiAgLy8gQWRtaW4gSUQgKGluIGEgcmVhbCBhcHAsIHdvdWxkIGNvbWUgZnJvbSBhdXRoKVxuICBjb25zdCBhZG1pbklkID0gMTtcbiAgXG4gIGxldCBtZXNzYWdlcyA9IFsuLi5tb2NrTWVzc2FnZXNdO1xuICBcbiAgaWYgKGZpbHRlciA9PT0gJ2luYm94Jykge1xuICAgIC8vIE1lc3NhZ2VzIHJlY2VpdmVkIGJ5IGFkbWluXG4gICAgbWVzc2FnZXMgPSBtZXNzYWdlcy5maWx0ZXIobXNnID0+IG1zZy5yZWNlaXZlcl9pZCA9PT0gYWRtaW5JZCAmJiBtc2cucmVjZWl2ZXJfdHlwZSA9PT0gJ2FkbWluJyk7XG4gIH0gZWxzZSBpZiAoZmlsdGVyID09PSAnc2VudCcpIHtcbiAgICAvLyBNZXNzYWdlcyBzZW50IGJ5IGFkbWluXG4gICAgbWVzc2FnZXMgPSBtZXNzYWdlcy5maWx0ZXIobXNnID0+IG1zZy5zZW5kZXJfaWQgPT09IGFkbWluSWQgJiYgbXNnLnNlbmRlcl90eXBlID09PSAnYWRtaW4nKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBbGwgbWVzc2FnZXMgKGJvdGggc2VudCBhbmQgcmVjZWl2ZWQpXG4gICAgbWVzc2FnZXMgPSBtZXNzYWdlcy5maWx0ZXIobXNnID0+IFxuICAgICAgKG1zZy5zZW5kZXJfaWQgPT09IGFkbWluSWQgJiYgbXNnLnNlbmRlcl90eXBlID09PSAnYWRtaW4nKSB8fFxuICAgICAgKG1zZy5yZWNlaXZlcl9pZCA9PT0gYWRtaW5JZCAmJiBtc2cucmVjZWl2ZXJfdHlwZSA9PT0gJ2FkbWluJylcbiAgICApO1xuICB9XG4gIFxuICAvLyBFbmhhbmNlIG1lc3NhZ2VzIHdpdGggc2VuZGVyIGFuZCByZWNlaXZlciBuYW1lc1xuICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHRoaXMgd291bGQgYmUgaGFuZGxlZCB3aXRoIGpvaW5zIGluIHRoZSBkYXRhYmFzZSBxdWVyeVxuICBjb25zdCBlbmhhbmNlZE1lc3NhZ2VzID0gbWVzc2FnZXMubWFwKG1lc3NhZ2UgPT4ge1xuICAgIGxldCBzZW5kZXJOYW1lID0gJ1Vua25vd24nO1xuICAgIGxldCByZWNlaXZlck5hbWUgPSAnVW5rbm93bic7XG4gICAgXG4gICAgLy8gR2V0IHNlbmRlciBuYW1lXG4gICAgaWYgKG1lc3NhZ2Uuc2VuZGVyX3R5cGUgPT09ICdzdHVkZW50Jykge1xuICAgICAgY29uc3Qgc3R1ZGVudCA9IG1vY2tTdHVkZW50cy5maW5kKHMgPT4gcy5pZCA9PT0gbWVzc2FnZS5zZW5kZXJfaWQpO1xuICAgICAgc2VuZGVyTmFtZSA9IHN0dWRlbnQgPyBzdHVkZW50Lm5hbWUgOiAnVW5rbm93biBTdHVkZW50JztcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2Uuc2VuZGVyX3R5cGUgPT09ICdmYWN1bHR5Jykge1xuICAgICAgY29uc3QgZmFjdWx0eSA9IG1vY2tGYWN1bHR5LmZpbmQoZiA9PiBmLmlkID09PSBtZXNzYWdlLnNlbmRlcl9pZCk7XG4gICAgICBzZW5kZXJOYW1lID0gZmFjdWx0eSA/IGZhY3VsdHkubmFtZSA6ICdVbmtub3duIEZhY3VsdHknO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5zZW5kZXJfdHlwZSA9PT0gJ2FkbWluJykge1xuICAgICAgc2VuZGVyTmFtZSA9ICdBZG1pbiBVc2VyJztcbiAgICB9XG4gICAgXG4gICAgLy8gR2V0IHJlY2VpdmVyIG5hbWVcbiAgICBpZiAobWVzc2FnZS5yZWNlaXZlcl90eXBlID09PSAnc3R1ZGVudCcpIHtcbiAgICAgIGNvbnN0IHN0dWRlbnQgPSBtb2NrU3R1ZGVudHMuZmluZChzID0+IHMuaWQgPT09IG1lc3NhZ2UucmVjZWl2ZXJfaWQpO1xuICAgICAgcmVjZWl2ZXJOYW1lID0gc3R1ZGVudCA/IHN0dWRlbnQubmFtZSA6ICdVbmtub3duIFN0dWRlbnQnO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5yZWNlaXZlcl90eXBlID09PSAnZmFjdWx0eScpIHtcbiAgICAgIGNvbnN0IGZhY3VsdHkgPSBtb2NrRmFjdWx0eS5maW5kKGYgPT4gZi5pZCA9PT0gbWVzc2FnZS5yZWNlaXZlcl9pZCk7XG4gICAgICByZWNlaXZlck5hbWUgPSBmYWN1bHR5ID8gZmFjdWx0eS5uYW1lIDogJ1Vua25vd24gRmFjdWx0eSc7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLnJlY2VpdmVyX3R5cGUgPT09ICdhZG1pbicpIHtcbiAgICAgIHJlY2VpdmVyTmFtZSA9ICdBZG1pbiBVc2VyJztcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICBzZW5kZXJfbmFtZTogc2VuZGVyTmFtZSxcbiAgICAgIHJlY2VpdmVyX25hbWU6IHJlY2VpdmVyTmFtZVxuICAgIH07XG4gIH0pO1xuICBcbiAgcmV0dXJuIGVuaGFuY2VkTWVzc2FnZXM7XG59O1xuXG4vKipcbiAqIFNlbmQgYSBuZXcgbWVzc2FnZVxuICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2VEYXRhIC0gTWVzc2FnZSBkYXRhXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIENyZWF0ZWQgbWVzc2FnZVxuICovXG5leHBvcnQgY29uc3Qgc2VuZE1lc3NhZ2UgPSBhc3luYyAobWVzc2FnZURhdGEpID0+IHtcbiAgLy8gU2ltdWxhdGUgbmV0d29yayByZXF1ZXN0XG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgXG4gIGNvbnN0IG5ld0lkID0gTWF0aC5tYXgoLi4ubW9ja01lc3NhZ2VzLm1hcChtID0+IG0uaWQpKSArIDE7XG4gIFxuICAvLyBBZG1pbiBJRCAoaW4gYSByZWFsIGFwcCwgd291bGQgY29tZSBmcm9tIGF1dGgpXG4gIGNvbnN0IGFkbWluSWQgPSAxO1xuICBcbiAgY29uc3QgbmV3TWVzc2FnZSA9IHtcbiAgICAuLi5tZXNzYWdlRGF0YSxcbiAgICBpZDogbmV3SWQsXG4gICAgc2VuZGVyX2lkOiBhZG1pbklkLFxuICAgIHNlbmRlcl90eXBlOiAnYWRtaW4nLFxuICAgIHNlbnRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICB9O1xuICBcbiAgbW9ja01lc3NhZ2VzLnB1c2gobmV3TWVzc2FnZSk7XG4gIFxuICAvLyBHZXQgc2VuZGVyIGFuZCByZWNlaXZlciBuYW1lc1xuICBsZXQgc2VuZGVyTmFtZSA9ICdBZG1pbiBVc2VyJztcbiAgbGV0IHJlY2VpdmVyTmFtZSA9ICdVbmtub3duJztcbiAgXG4gIGlmIChuZXdNZXNzYWdlLnJlY2VpdmVyX3R5cGUgPT09ICdzdHVkZW50Jykge1xuICAgIGNvbnN0IHN0dWRlbnQgPSBtb2NrU3R1ZGVudHMuZmluZChzID0+IHMuaWQgPT09IG5ld01lc3NhZ2UucmVjZWl2ZXJfaWQpO1xuICAgIHJlY2VpdmVyTmFtZSA9IHN0dWRlbnQgPyBzdHVkZW50Lm5hbWUgOiAnVW5rbm93biBTdHVkZW50JztcbiAgfSBlbHNlIGlmIChuZXdNZXNzYWdlLnJlY2VpdmVyX3R5cGUgPT09ICdmYWN1bHR5Jykge1xuICAgIGNvbnN0IGZhY3VsdHkgPSBtb2NrRmFjdWx0eS5maW5kKGYgPT4gZi5pZCA9PT0gbmV3TWVzc2FnZS5yZWNlaXZlcl9pZCk7XG4gICAgcmVjZWl2ZXJOYW1lID0gZmFjdWx0eSA/IGZhY3VsdHkubmFtZSA6ICdVbmtub3duIEZhY3VsdHknO1xuICB9IGVsc2UgaWYgKG5ld01lc3NhZ2UucmVjZWl2ZXJfdHlwZSA9PT0gJ2FkbWluJykge1xuICAgIGNvbnN0IGFkbWluID0gbW9ja1N0dWRlbnRzLmZpbmQoYSA9PiBhLmlkID09PSBuZXdNZXNzYWdlLnJlY2VpdmVyX2lkKTtcbiAgICByZWNlaXZlck5hbWUgPSBhZG1pbiA/IGFkbWluLm5hbWUgOiAnQWRtaW4gVXNlcic7XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgLi4ubmV3TWVzc2FnZSxcbiAgICBzZW5kZXJfbmFtZTogc2VuZGVyTmFtZSxcbiAgICByZWNlaXZlcl9uYW1lOiByZWNlaXZlck5hbWVcbiAgfTtcbn07XG5cbi8qKlxuICogRGVsZXRlIGEgbWVzc2FnZVxuICogQHBhcmFtIHtudW1iZXJ9IG1lc3NhZ2VJZCAtIE1lc3NhZ2UgSURcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSAtIFN1Y2Nlc3Mgc3RhdHVzXG4gKi9cbmV4cG9ydCBjb25zdCBkZWxldGVNZXNzYWdlID0gYXN5bmMgKG1lc3NhZ2VJZCkgPT4ge1xuICAvLyBTaW11bGF0ZSBuZXR3b3JrIHJlcXVlc3RcbiAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICBcbiAgY29uc3QgaWQgPSBwYXJzZUludChtZXNzYWdlSWQpO1xuICBjb25zdCBtZXNzYWdlSW5kZXggPSBtb2NrTWVzc2FnZXMuZmluZEluZGV4KG0gPT4gbS5pZCA9PT0gaWQpO1xuICBcbiAgaWYgKG1lc3NhZ2VJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcignTWVzc2FnZSBub3QgZm91bmQnKTtcbiAgXG4gIG1vY2tNZXNzYWdlcy5zcGxpY2UobWVzc2FnZUluZGV4LCAxKTtcbiAgXG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gPT09PT09PT09PT0gTEVBVkUgUkVRVUVTVFMgPT09PT09PT09PT1cblxuLyoqXG4gKiBHZXQgbGVhdmUgcmVxdWVzdHMgd2l0aCBvcHRpb25hbCBmaWx0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gcXVlcnlQYXJhbXMgLSBGaWx0ZXIgcGFyYW1ldGVyc1xuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fSAtIExpc3Qgb2YgbGVhdmUgcmVxdWVzdHNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldExlYXZlUmVxdWVzdHMgPSBhc3luYyAocXVlcnlQYXJhbXMgPSB7fSkgPT4ge1xuICAvLyBTaW11bGF0ZSBuZXR3b3JrIHJlcXVlc3RcbiAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICBcbiAgY29uc3QgeyBzdGF0dXMsIGRlcGFydG1lbnRJZCwgZmFjdWx0eUlkLCBkYXRlX2Zyb20sIGRhdGVfdG8gfSA9IHF1ZXJ5UGFyYW1zO1xuICBcbiAgbGV0IGxlYXZlUmVxdWVzdHMgPSBbLi4ubW9ja0xlYXZlUmVxdWVzdHNdO1xuICBcbiAgaWYgKHN0YXR1cykge1xuICAgIGxlYXZlUmVxdWVzdHMgPSBsZWF2ZVJlcXVlc3RzLmZpbHRlcihyZXF1ZXN0ID0+IHJlcXVlc3Quc3RhdHVzID09PSBzdGF0dXMpO1xuICB9XG4gIFxuICBpZiAoZGVwYXJ0bWVudElkKSB7XG4gICAgbGVhdmVSZXF1ZXN0cyA9IGxlYXZlUmVxdWVzdHMuZmlsdGVyKHJlcXVlc3QgPT4gcmVxdWVzdC5kZXBhcnRtZW50SWQgPT09IHBhcnNlSW50KGRlcGFydG1lbnRJZCkpO1xuICB9XG4gIFxuICBpZiAoZmFjdWx0eUlkKSB7XG4gICAgbGVhdmVSZXF1ZXN0cyA9IGxlYXZlUmVxdWVzdHMuZmlsdGVyKHJlcXVlc3QgPT4gcmVxdWVzdC5mYWN1bHR5SWQgPT09IHBhcnNlSW50KGZhY3VsdHlJZCkpO1xuICB9XG4gIFxuICBpZiAoZGF0ZV9mcm9tKSB7XG4gICAgY29uc3QgZnJvbURhdGUgPSBuZXcgRGF0ZShkYXRlX2Zyb20pO1xuICAgIGxlYXZlUmVxdWVzdHMgPSBsZWF2ZVJlcXVlc3RzLmZpbHRlcihyZXF1ZXN0ID0+IG5ldyBEYXRlKHJlcXVlc3QubGVhdmVfZGF0ZSkgPj0gZnJvbURhdGUpO1xuICB9XG4gIFxuICBpZiAoZGF0ZV90bykge1xuICAgIGNvbnN0IHRvRGF0ZSA9IG5ldyBEYXRlKGRhdGVfdG8pO1xuICAgIGxlYXZlUmVxdWVzdHMgPSBsZWF2ZVJlcXVlc3RzLmZpbHRlcihyZXF1ZXN0ID0+IG5ldyBEYXRlKHJlcXVlc3QubGVhdmVfZGF0ZSkgPD0gdG9EYXRlKTtcbiAgfVxuICBcbiAgLy8gQWRkIHJlbGF0ZWQgZGF0YVxuICBjb25zdCByZXF1ZXN0c1dpdGhSZWxhdGVkID0gbGVhdmVSZXF1ZXN0cy5tYXAocmVxdWVzdCA9PiB7XG4gICAgY29uc3QgZmFjdWx0eSA9IG1vY2tGYWN1bHR5LmZpbmQoZiA9PiBmLmlkID09PSByZXF1ZXN0LmZhY3VsdHlJZCk7XG4gICAgY29uc3QgZGVwYXJ0bWVudCA9IG1vY2tEZXBhcnRtZW50cy5maW5kKGQgPT4gZC5pZCA9PT0gcmVxdWVzdC5kZXBhcnRtZW50SWQpO1xuICAgIGNvbnN0IGNsYXNzSW5mbyA9IG1vY2tDbGFzc2VzLmZpbmQoYyA9PiBjLmlkID09PSByZXF1ZXN0LmNsYXNzSWQpO1xuICAgIGNvbnN0IHNlY3Rpb24gPSBtb2NrU2VjdGlvbnMuZmluZChzID0+IHMuaWQgPT09IHJlcXVlc3Quc2VjdGlvbklkKTtcbiAgICBjb25zdCBjb3Vyc2UgPSBtb2NrQ291cnNlcy5maW5kKGMgPT4gYy5pZCA9PT0gcmVxdWVzdC5jb3Vyc2VJZCk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlcXVlc3QsXG4gICAgICBmYWN1bHR5LFxuICAgICAgZGVwYXJ0bWVudCxcbiAgICAgIGNsYXNzOiBjbGFzc0luZm8sXG4gICAgICBzZWN0aW9uLFxuICAgICAgY291cnNlXG4gICAgfTtcbiAgfSk7XG4gIFxuICByZXR1cm4gcmVxdWVzdHNXaXRoUmVsYXRlZDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGxlYXZlIHJlcXVlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZURhdGEgLSBMZWF2ZSByZXF1ZXN0IGRhdGFcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IC0gQ3JlYXRlZCBsZWF2ZSByZXF1ZXN0XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVMZWF2ZVJlcXVlc3QgPSBhc3luYyAobGVhdmVEYXRhKSA9PiB7XG4gIC8vIFNpbXVsYXRlIG5ldHdvcmsgcmVxdWVzdFxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gIFxuICBjb25zdCBuZXdJZCA9IE1hdGgubWF4KC4uLm1vY2tMZWF2ZVJlcXVlc3RzLm1hcChyID0+IHIuaWQpKSArIDE7XG4gIFxuICBjb25zdCBuZXdSZXF1ZXN0ID0ge1xuICAgIC4uLmxlYXZlRGF0YSxcbiAgICBpZDogbmV3SWQsXG4gICAgc3RhdHVzOiAnUGVuZGluZycsXG4gICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICB9O1xuICBcbiAgbW9ja0xlYXZlUmVxdWVzdHMucHVzaChuZXdSZXF1ZXN0KTtcbiAgXG4gIC8vIEFkZCByZWxhdGVkIGRhdGFcbiAgY29uc3QgZmFjdWx0eSA9IG1vY2tGYWN1bHR5LmZpbmQoZiA9PiBmLmlkID09PSBuZXdSZXF1ZXN0LmZhY3VsdHlJZCk7XG4gIGNvbnN0IGRlcGFydG1lbnQgPSBtb2NrRGVwYXJ0bWVudHMuZmluZChkID0+IGQuaWQgPT09IG5ld1JlcXVlc3QuZGVwYXJ0bWVudElkKTtcbiAgY29uc3QgY2xhc3NJbmZvID0gbW9ja0NsYXNzZXMuZmluZChjID0+IGMuaWQgPT09IG5ld1JlcXVlc3QuY2xhc3NJZCk7XG4gIGNvbnN0IHNlY3Rpb24gPSBtb2NrU2VjdGlvbnMuZmluZChzID0+IHMuaWQgPT09IG5ld1JlcXVlc3Quc2VjdGlvbklkKTtcbiAgY29uc3QgY291cnNlID0gbW9ja0NvdXJzZXMuZmluZChjID0+IGMuaWQgPT09IG5ld1JlcXVlc3QuY291cnNlSWQpO1xuICBcbiAgcmV0dXJuIHtcbiAgICAuLi5uZXdSZXF1ZXN0LFxuICAgIGZhY3VsdHksXG4gICAgZGVwYXJ0bWVudCxcbiAgICBjbGFzczogY2xhc3NJbmZvLFxuICAgIHNlY3Rpb24sXG4gICAgY291cnNlXG4gIH07XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBsZWF2ZSByZXF1ZXN0IHN0YXR1c1xuICogQHBhcmFtIHtudW1iZXJ9IGxlYXZlSWQgLSBMZWF2ZSByZXF1ZXN0IElEXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFVwZGF0ZSBkYXRhIChzdGF0dXMpXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIFVwZGF0ZWQgbGVhdmUgcmVxdWVzdFxuICovXG5leHBvcnQgY29uc3QgdXBkYXRlTGVhdmVTdGF0dXMgPSBhc3luYyAobGVhdmVJZCwgZGF0YSkgPT4ge1xuICAvLyBTaW11bGF0ZSBuZXR3b3JrIHJlcXVlc3RcbiAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICBcbiAgY29uc3QgaWQgPSBwYXJzZUludChsZWF2ZUlkKTtcbiAgY29uc3QgbGVhdmVJbmRleCA9IG1vY2tMZWF2ZVJlcXVlc3RzLmZpbmRJbmRleChyID0+IHIuaWQgPT09IGlkKTtcbiAgXG4gIGlmIChsZWF2ZUluZGV4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKCdMZWF2ZSByZXF1ZXN0IG5vdCBmb3VuZCcpO1xuICBcbiAgY29uc3QgbGVhdmUgPSBtb2NrTGVhdmVSZXF1ZXN0c1tsZWF2ZUluZGV4XTtcbiAgXG4gIGNvbnN0IHVwZGF0ZWRMZWF2ZSA9IHtcbiAgICAuLi5sZWF2ZSxcbiAgICBzdGF0dXM6IGRhdGEuc3RhdHVzLFxuICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICB9O1xuICBcbiAgbW9ja0xlYXZlUmVxdWVzdHNbbGVhdmVJbmRleF0gPSB1cGRhdGVkTGVhdmU7XG4gIFxuICAvLyBBZGQgcmVsYXRlZCBkYXRhXG4gIGNvbnN0IGZhY3VsdHkgPSBtb2NrRmFjdWx0eS5maW5kKGYgPT4gZi5pZCA9PT0gdXBkYXRlZExlYXZlLmZhY3VsdHlJZCk7XG4gIGNvbnN0IGRlcGFydG1lbnQgPSBtb2NrRGVwYXJ0bWVudHMuZmluZChkID0+IGQuaWQgPT09IHVwZGF0ZWRMZWF2ZS5kZXBhcnRtZW50SWQpO1xuICBjb25zdCBjbGFzc0luZm8gPSBtb2NrQ2xhc3Nlcy5maW5kKGMgPT4gYy5pZCA9PT0gdXBkYXRlZExlYXZlLmNsYXNzSWQpO1xuICBjb25zdCBzZWN0aW9uID0gbW9ja1NlY3Rpb25zLmZpbmQocyA9PiBzLmlkID09PSB1cGRhdGVkTGVhdmUuc2VjdGlvbklkKTtcbiAgY29uc3QgY291cnNlID0gbW9ja0NvdXJzZXMuZmluZChjID0+IGMuaWQgPT09IHVwZGF0ZWRMZWF2ZS5jb3Vyc2VJZCk7XG4gIFxuICByZXR1cm4ge1xuICAgIC4uLnVwZGF0ZWRMZWF2ZSxcbiAgICBmYWN1bHR5LFxuICAgIGRlcGFydG1lbnQsXG4gICAgY2xhc3M6IGNsYXNzSW5mbyxcbiAgICBzZWN0aW9uLFxuICAgIGNvdXJzZVxuICB9O1xufTtcblxuLyoqXG4gKiBBcHByb3ZlIGEgbGVhdmUgcmVxdWVzdFxuICogQHBhcmFtIHtudW1iZXJ9IGxlYXZlSWQgLSBMZWF2ZSByZXF1ZXN0IElEXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIFVwZGF0ZWQgbGVhdmUgcmVxdWVzdFxuICovXG5leHBvcnQgY29uc3QgYXBwcm92ZUxlYXZlID0gYXN5bmMgKGxlYXZlSWQpID0+IHtcbiAgcmV0dXJuIHVwZGF0ZUxlYXZlU3RhdHVzKGxlYXZlSWQsIHsgc3RhdHVzOiAnQXBwcm92ZWQnIH0pO1xufTtcblxuLyoqXG4gKiBSZWplY3QgYSBsZWF2ZSByZXF1ZXN0XG4gKiBAcGFyYW0ge251bWJlcn0gbGVhdmVJZCAtIExlYXZlIHJlcXVlc3QgSURcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IC0gVXBkYXRlZCBsZWF2ZSByZXF1ZXN0XG4gKi9cbmV4cG9ydCBjb25zdCByZWplY3RMZWF2ZSA9IGFzeW5jIChsZWF2ZUlkKSA9PiB7XG4gIHJldHVybiB1cGRhdGVMZWF2ZVN0YXR1cyhsZWF2ZUlkLCB7IHN0YXR1czogJ1JlamVjdGVkJyB9KTtcbn07XG5cbi8vID09PT09PT09PT09IEFOQUxZVElDUyA9PT09PT09PT09PVxuXG4vKipcbiAqIEdldCBhbGwgYW5hbHl0aWNzIGRhdGFcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IC0gQW5hbHl0aWNzIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEFsbEFuYWx5dGljcyA9IGFzeW5jICgpID0+IHtcbiAgLy8gU2ltdWxhdGUgbmV0d29yayByZXF1ZXN0XG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgXG4gIHJldHVybiB7XG4gICAgZGVwYXJ0bWVudERpc3RyaWJ1dGlvbjogbW9ja0RlcGFydG1lbnREaXN0cmlidXRpb24sXG4gICAgZmFjdWx0eVBlcmZvcm1hbmNlOiBtb2NrRmFjdWx0eVBlcmZvcm1hbmNlLFxuICAgIHJldmVudWVEYXRhOiBtb2NrUmV2ZW51ZURhdGEsXG4gICAgYXR0ZW5kYW5jZUFuYWx5dGljczogbW9ja0F0dGVuZGFuY2VBbmFseXRpY3NcbiAgfTtcbn07XG5cbi8qKlxuICogR2V0IGRlcGFydG1lbnQgZGlzdHJpYnV0aW9uIGFuYWx5dGljc1xuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSBEZXBhcnRtZW50IGRpc3RyaWJ1dGlvbiBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBnZXREZXBhcnRtZW50RGlzdHJpYnV0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAvLyBTaW11bGF0ZSBuZXR3b3JrIHJlcXVlc3RcbiAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICBcbiAgcmV0dXJuIG1vY2tEZXBhcnRtZW50RGlzdHJpYnV0aW9uO1xufTtcblxuLyoqXG4gKiBHZXQgZmFjdWx0eSBwZXJmb3JtYW5jZSBhbmFseXRpY3NcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IC0gRmFjdWx0eSBwZXJmb3JtYW5jZSBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRGYWN1bHR5UGVyZm9ybWFuY2UgPSBhc3luYyAoKSA9PiB7XG4gIC8vIFNpbXVsYXRlIG5ldHdvcmsgcmVxdWVzdFxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gIFxuICByZXR1cm4gbW9ja0ZhY3VsdHlQZXJmb3JtYW5jZTtcbn07XG5cbi8qKlxuICogR2V0IHJldmVudWUgYW5hbHl0aWNzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIFJldmVudWUgZGF0YVxuICovXG5leHBvcnQgY29uc3QgZ2V0UmV2ZW51ZURhdGEgPSBhc3luYyAoKSA9PiB7XG4gIC8vIFNpbXVsYXRlIG5ldHdvcmsgcmVxdWVzdFxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gIFxuICByZXR1cm4gbW9ja1JldmVudWVEYXRhO1xufTsiXSwibmFtZXMiOlsibW9ja1N0dWRlbnRzIiwibW9ja0ZhY3VsdHkiLCJtb2NrRGVwYXJ0bWVudHMiLCJtb2NrQ2xhc3NlcyIsIm1vY2tTZWN0aW9ucyIsIm1vY2tDb3Vyc2VzIiwibW9ja1NjaGVkdWxlcyIsIm1vY2tBdHRlbmRhbmNlIiwibW9ja0V2ZW50cyIsIm1vY2tJbnZvaWNlcyIsIm1vY2tNZXNzYWdlcyIsIm1vY2tMZWF2ZVJlcXVlc3RzIiwibW9ja0F0dGVuZGFuY2VBbmFseXRpY3MiLCJtb2NrRGVwYXJ0bWVudERpc3RyaWJ1dGlvbiIsIm1vY2tGYWN1bHR5UGVyZm9ybWFuY2UiLCJtb2NrUmV2ZW51ZURhdGEiLCJnZXRVc2VycyIsInF1ZXJ5UGFyYW1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0Iiwicm9sZSIsImRlcGFydG1lbnRJZCIsImNsYXNzSWQiLCJzZWN0aW9uSWQiLCJzZWFyY2giLCJ1c2VyRGF0YSIsImZpbHRlciIsInVzZXIiLCJwYXJzZUludCIsInNlYXJjaExvd2VyIiwidG9Mb3dlckNhc2UiLCJuYW1lIiwiaW5jbHVkZXMiLCJlbWFpbCIsImdldERlcGFydG1lbnRzIiwiZ2V0Q2xhc3NlcyIsImNsYXNzRGF0YSIsImNscyIsImdldFNlY3Rpb25zIiwic2VjdGlvbkRhdGEiLCJzZWN0aW9uIiwiY3JlYXRlVXNlciIsIm5ld0lkIiwiTWF0aCIsIm1heCIsIm1hcCIsImYiLCJpZCIsInMiLCJuZXdVc2VyIiwicGFzc3dvcmRfaGFzaCIsInBhc3N3b3JkIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInVwZGF0ZWRfYXQiLCJwdXNoIiwidXBkYXRlVXNlciIsInVzZXJJZCIsImlzU3R1ZGVudCIsInVzZXJJbmRleCIsImZpbmRJbmRleCIsIkVycm9yIiwidXBkYXRlZFVzZXIiLCJkZWxldGVVc2VyIiwic3R1ZGVudEluZGV4Iiwic3BsaWNlIiwiZmFjdWx0eUluZGV4IiwiZ2V0Q291cnNlcyIsImNvdXJzZXMiLCJjb3Vyc2UiLCJjb3Vyc2VfY29kZSIsImNyZWF0ZUNvdXJzZSIsImNvdXJzZURhdGEiLCJjIiwibmV3Q291cnNlIiwidXBkYXRlQ291cnNlIiwiY291cnNlSWQiLCJjb3Vyc2VJbmRleCIsInVwZGF0ZWRDb3Vyc2UiLCJkZWxldGVDb3Vyc2UiLCJnZXRTY2hlZHVsZXMiLCJ2aWV3X3R5cGUiLCJmYWN1bHR5SWQiLCJkYXkiLCJzY2hlZHVsZXMiLCJzY2hlZHVsZSIsImRheV9vZl93ZWVrIiwiZmluZCIsInNjaGVkdWxlc1dpdGhSZWxhdGVkIiwiZmFjdWx0eSIsImNsYXNzSW5mbyIsImNsYXNzIiwiY3JlYXRlU2NoZWR1bGUiLCJzY2hlZHVsZURhdGEiLCJuZXdTY2hlZHVsZSIsInVwZGF0ZVNjaGVkdWxlIiwic2NoZWR1bGVJZCIsInNjaGVkdWxlSW5kZXgiLCJ1cGRhdGVkU2NoZWR1bGUiLCJkZWxldGVTY2hlZHVsZSIsImdldEF0dGVuZGFuY2UiLCJkYXRlIiwic3RhdHVzIiwiYXR0ZW5kYW5jZSIsImRhdGVPYmoiLCJ5ZWFyIiwiZ2V0RnVsbFllYXIiLCJtb250aCIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImEiLCJyZWNvcmREYXRlIiwic3R1ZGVudCIsInN0dWRlbnRJZCIsImF0dGVuZGFuY2VXaXRoUmVsYXRlZCIsInJlY29yZCIsInVwZGF0ZUF0dGVuZGFuY2UiLCJhdHRlbmRhbmNlSWQiLCJkYXRhIiwiYXR0ZW5kYW5jZUluZGV4IiwidXBkYXRlZEF0dGVuZGFuY2UiLCJnZXRBdHRlbmRhbmNlQW5hbHl0aWNzIiwiZ2V0RXZlbnRzIiwiZnJvbV9kYXRlIiwidG9fZGF0ZSIsImF1ZGllbmNlX3R5cGUiLCJldmVudHMiLCJmcm9tRGF0ZSIsImV2ZW50IiwiZXZlbnRfZGF0ZSIsInRvRGF0ZSIsImNyZWF0ZUV2ZW50IiwiZXZlbnREYXRhIiwiZSIsIm5ld0V2ZW50IiwidXBkYXRlRXZlbnQiLCJldmVudElkIiwiZXZlbnRJbmRleCIsInVwZGF0ZWRFdmVudCIsImRlbGV0ZUV2ZW50IiwiZ2V0SW52b2ljZXMiLCJwYWlkIiwiaW52b2ljZXMiLCJpbnZvaWNlIiwidW5kZWZpbmVkIiwiaXNQYWlkIiwiZ2VuZXJhdGVkX2F0IiwiaW52b2ljZXNXaXRoU3R1ZGVudHMiLCJjcmVhdGVJbnZvaWNlIiwiaW52b2ljZURhdGEiLCJpIiwidG9kYXkiLCJpbnZvaWNlTnVtYmVyIiwiU3RyaW5nIiwicGFkU3RhcnQiLCJuZXdJbnZvaWNlIiwiaW52b2ljZV9udW1iZXIiLCJ1cGRhdGVJbnZvaWNlIiwiaW52b2ljZUlkIiwiaW52b2ljZUluZGV4IiwidXBkYXRlZEludm9pY2UiLCJkZWxldGVJbnZvaWNlIiwibWFya0ludm9pY2VQYWlkIiwiZ2V0TWVzc2FnZXMiLCJhZG1pbklkIiwibWVzc2FnZXMiLCJtc2ciLCJyZWNlaXZlcl9pZCIsInJlY2VpdmVyX3R5cGUiLCJzZW5kZXJfaWQiLCJzZW5kZXJfdHlwZSIsImVuaGFuY2VkTWVzc2FnZXMiLCJtZXNzYWdlIiwic2VuZGVyTmFtZSIsInJlY2VpdmVyTmFtZSIsInNlbmRlcl9uYW1lIiwicmVjZWl2ZXJfbmFtZSIsInNlbmRNZXNzYWdlIiwibWVzc2FnZURhdGEiLCJtIiwibmV3TWVzc2FnZSIsInNlbnRfYXQiLCJhZG1pbiIsImRlbGV0ZU1lc3NhZ2UiLCJtZXNzYWdlSWQiLCJtZXNzYWdlSW5kZXgiLCJnZXRMZWF2ZVJlcXVlc3RzIiwiZGF0ZV9mcm9tIiwiZGF0ZV90byIsImxlYXZlUmVxdWVzdHMiLCJyZXF1ZXN0IiwibGVhdmVfZGF0ZSIsInJlcXVlc3RzV2l0aFJlbGF0ZWQiLCJkZXBhcnRtZW50IiwiZCIsImNyZWF0ZUxlYXZlUmVxdWVzdCIsImxlYXZlRGF0YSIsInIiLCJuZXdSZXF1ZXN0IiwidXBkYXRlTGVhdmVTdGF0dXMiLCJsZWF2ZUlkIiwibGVhdmVJbmRleCIsImxlYXZlIiwidXBkYXRlZExlYXZlIiwiYXBwcm92ZUxlYXZlIiwicmVqZWN0TGVhdmUiLCJnZXRBbGxBbmFseXRpY3MiLCJkZXBhcnRtZW50RGlzdHJpYnV0aW9uIiwiZmFjdWx0eVBlcmZvcm1hbmNlIiwicmV2ZW51ZURhdGEiLCJhdHRlbmRhbmNlQW5hbHl0aWNzIiwiZ2V0RGVwYXJ0bWVudERpc3RyaWJ1dGlvbiIsImdldEZhY3VsdHlQZXJmb3JtYW5jZSIsImdldFJldmVudWVEYXRhIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./utils/adminApi.js\n"));

/***/ })

});